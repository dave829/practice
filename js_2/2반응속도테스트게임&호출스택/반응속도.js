//1일단 html에서 화면을 불러와야겠죠.쿼리셀렉터로가져와서 변수로 저장하고 그리고 변수에 저장하는 이유는 이스크린 태그가 두고두고 쓰일수있기떄문임! 
var 스크린 = document.querySelector('#screen'); 

//클릭 이벤트를 설명하자면,
//클릭이벤트는 if조건문으로되어 있고 3가지로 나눠서 실행이 되게끔 짯다.
//3가지 조건은 screen 이라는 아이디의 태그를 불러오는데, 그 태그의 클래스는 waiting 이다.
//그래서 밑에 코드를 보면,, waiting 일 경우 ready로 바꾸고 ready일경우 now로 바꾼다는 if조건문을 걸어놨다. 이렇게 3가지이다.
//즉, 클릭하면 뭔일이 생기냐면, 무조건 screen클래스를 쳐다보게 코딩해놨다. 스크린.classList.contains('waiting') 이렇게 ...
// waiting에 걸릴경우 ready로 바꿔라 이런식으로 해놔써 
//여튼 클릭할시 지금 screen클래스의 어떤 컨테인인지에따라 걸리면 그에맞게 실행되는 구조이다.
//클릭을했는데, 지금 현재 screen클래스의 now이면 waiting으로 가라 이렇게 짜놨다.
//그니까 이 코드에서 클릭이벤트로 이게 다 돌아간다는 소리다.
//즉, 중요한건 애초에 코드가 클릭이벤트라서 무조건 클릭을 통해서 화면이 바뀐다는 소리다.
//그러나 저 중간에 스크린.click(); 이라고 넣어주면 자동으로 알아서 클릭해주는 효과 이므로 그 다음의 상태로 자동으로 넘어가겠죠...

//3스크린의 상태가 있다.스크린의 상태는 대기 준비 시작 으로 나뉘기 때문에 만들어야함.
//그래서 일단 딕셔너리로 쓸고 준비는 해놓음, 
//처음에는 클래스가 waiting이죠, 클래스가 wainting일때 준비상태라는걸 알수 있잖아요 그래서~
var 상태 = {
    
};
//10 여기는 시간을 체크하는 방법(자바스크립트에서 시간을 체크하는 방법이 몇가지가 있는데요 이방법을 써봅시다)

//22 여기에 왜 시작시간은 바깥에 두고, 끝시간은 저 함수 안에 두냐면,
// 시작시간은 바깥에 두므로써, 일단 페이지가 처음 로딩이 될때 시작시간까지 다 로딩이되서 이 부분이 실행이 되고, 시작시간은 뉴데이트라는걸로 시간이 딱 기록이 여기에 된다.
//근데 저 이벤트안에들어있는 끝시간은 일단 이벤트는 비동기이다. 즉 저 클릭이벤트의 콜백함수자체는 비동기이다.
//그면 비동기는 항상 말하는거지만, 언제 실행될지 모른다.대기상태에 있다가, 실행이 되는 순간에~저렇게 끝시간해서 실행이되서 변수로 기록을 해주는거다. 즉 각자 역할이 다르다고보면된다.
//var 시작시간 = new Date();//11 이렇게 new Date로 현재시간을 기록할수 있다.
//21 보통은 뉴데이트를 쓴다.

//22 끝시간을 미리 변수에 할당해놔도, 이렇게 해줘도 상관은 없다.
//var 끝시간; //23 애는 바깥으로 빼놔야되는 경우(스코프 문제 떄문에)가 생길지도 모르지만, 지금은 스코프가 다르기 떄문에 굳이 뺼 필요가 없다.


//////////////////////////////
//24 지금 우리가 해야되는것은 사실 시작시간을 체크하려는게 아니라, 
//화면이 초록색이 됬을때 부터 시간을 체크해서~파란색으로 넘어갈때의 시간을 체크하는게 목표다.
//그런데 그전에 해야할 기능이 뭐냐면, 
//준비상태일때(빨간색)에서 랜덤한시간이 흐르고 갑자기 색깔이 초록색으로바뀌고, 초록색으로바뀌면서 클릭해서 파란색이되는건데,
//일단 빨간색에서 초록색으로 가는 그 랜덤한시간을 구현해야한다.즉,빨간색에서 랜덤한시간 뒤에 초록색으로 딱 바뀌는게 되야된다. 
//////////////////////////////


//2이제 이스크린에 클릭을해서 우리가 항상 하나의 기능을 붙였으면 진짜 클릭이되는지 콜솔로그로 테스트!

//14 또 다른 시간을 계산(체크)하는 방법은 , 콜솔타임이라는게 있다.
//console.time('시간');//15 여기 괄호안에 들어가는 이름은 timeEnd와 똑같이 맞춰줘야된다!

//18 그리고 또 다른시간체크 방법으로 퍼포먼스가 있는데,퍼포먼스나우는 정밀한 시간을 측정해야될떄 쓴다 왜냐면 로그찍어보면 뒤에 소수자리가 엄청많다..
//var 시작시간 = performance.now();

//코드_기초지식> 여기 코드에서 new if else ifelse var funciton 등등 이런거를 예약어라고 부르는데, 예약어는,,
//예약어는 일단 변수명자체로 쓸수없다. 예를들면 var var = 이렇게 안된다. var function = 이것도 안된다.
//자바스크립트에서 아 애네는 변수이름으로 쓰지마 애네는 다 각자의 역할이 있어, 라고 하는거다. 여튼 변수명으로 못쓴다.

//30 이제 시간을 기록하는걸 구현해야되는데, 뉴데이터 함수를 이용해서 한다.new Date() 이거다. 이거를 시작시간 끝시간 변수에 저장해서, 끝시간에서 시작시간을 뺴서 나온 시간은 걸린시간이 되는거다.
//그러기 위해서는 스코프가 걸리기 떄문에 시작시간,끝시간을 전역스코프에 만들어준다음 따로 값을 받아보도록한다.
//왜냐면 비동기 특성상 비동기함수가 종료되면, 변수에 저장된 데이터가 날라가 버리기 떄문에 외부에 값을 저장하는걸로 한다. 
var 시작시간; 
var 끝시간;
var 기록=[]; //34 여기에(전역스코프에) 여태껏나온 시간들을 저장하기위한 용도로 기록을 만들어놓는다.
var 타임아웃; //41 전역스코프에 타임아웃변수를 선언해줌으로써 내부에서 외부를 스코프를 타고 찾을수있게 해준다.(이렇게 안하면 스코프때매(데이터가 날라가므로) 찾지못하므로 여기에 뺴주는거임 )
스크린.addEventListener('click',function(){ 
    //var 끝시간 = new Date(); //12 여기서는 클릭을했을때 그클릭을 한 시간이 기록된다.(즉 끝시간을 기록할수가 있다.)
    //console.log((끝시간-시작시간)/1000); //13 시간체크방법,여기서 콜솔로그로 일단 클릭해서 얼마나 시간이 걸리는지 측정하는 걸 테스트해보기위해 
    //끝시간-시작시간을 뺴서 측정을 해보면 숫자가나오는데, 그 숫자에 1000을 나누면 멏초가 걸리는지 나온다. 여기서 1000은 밀리쎄컨즈다. 여하튼 초를 계산을 이걸로할수가 있다.

    //var 끝시간 = performance.now(); //19 여기도 해주고 
    //console.log((끝시간-시작시간)/1000); //20 로그는 여기서 찍어줌,,

    //15 그리고 이벤트들어가는 부분 여기에 타임엔드를 넣어준다. 그러면 즉, 저기 콘솔타임과 여기 콘솔타임엔드 사이의 시간을 체크해주는 기능이다.
    //console.timeEnd('시간');//16 여기 괄호안에 들어가는 이름은 time과 똑같이 맞춰줘야된다!
    //17 이렇게 콘솔로 측정하는 방법은 이거는 실제 서비스에 쓴다기 보다는, 그냥 디버깅 할때,디버깅(버그잡을떄)할때 쓴다.예를들어 어떤 부분에서 코드가 느리다 할때 이런걸 시간체크를 할떄 쓰는거다.
    //생각보다 엄청 유용하다.

    //4 여기서 classList해서 contains를 쓴다. 그래서~
    //if문으로 감싼다. 
    if(스크린.classList.contains('waiting')){ //5 아쿠아색/현재 대기상태인지 파악!(이러면 준비중일 상태일때 로그가 찍히겠죠.) 아쿠아색일때 클릭을하면 밑의 코드가 실행되요~
        //console.log('클릭!'); 이제 로그는 지우고
        //6 이제 이 스크린을 클릭을하면 그다음은 어떻게 해야 겠어요? 그렇죠 웨이팅을 지우고 레디를 추가하면되겠죠
        스크린.classList.remove('waiting');//자바스크립트는 최소한의 것들만 이렇게 쓰는게 좋다.//그리고 클래스를 쓰면 좋은점은 이렇게 현재 준비상태인지 차악이 가능하다는것!
        스크린.classList.add('ready'); //7 빨간상태/이렇게하면 클릭하면 화면이 빨개집니다. 시작 즉, 준비화면이죠
        //스크린.style.backgroundColor = 'red'; //이렇게 js에서 css를 처리를 할수는있지만, css는 css에서 처리하는게 빠르고,
        //스크린.style.color='white'; // 여기서 이렇게 하면 일을두번해야된다,이렇게 두번 적어줘야한다. 그냥 css에서 한방에 처리하는게 빠름
        //9 화면별로 기능에 알맞는 텍스트를 넣자
        스크린.textContent='초록색이 되면 클릭하세요!';
        
        //25 랜덤한 시간기능을 만들기위해 셋타임아웃으로 구현해준다
        //41 셋타임아웃은 결론적으로 언제실행되냐면 랜덤한시간뒤에 실행!!이된다.즉  Math.floor(Math.random()*1000)+2000 이시간 뒤에 바로실행이되니까 저시간전에는 실행이되지않는다는거다.즉,이말은 저시간전에는 시작시간도 실행이되지않는다는거다.
        타임아웃=setTimeout(function(){ //39 여기서는 셋타임아웃이 자동실행이 되지않게 타임아웃이라는 변수를 만들어 셋타임아웃 기능을 저장시켜준다
            시작시간=new Date(); //시작시간코드는 이 위치에 시작시간이 있어야됨(그래야 순차적으로 실행되니까 시작시간먼저 실행이되고(데이터들어가고)난 다음 이 밑에 코드가 실행되는 순서임
            //console.log('시작시간 값',시작시간);
            스크린.click(); //26 이 코드는 클릭이벤트를 다시 실행시켜주는 코드이다.즉 스크린.addEventListener('click',function(){  이부분에서 클릭저 함수를 실행시켜줌으로해서, 지금 화면의 클래스의위치에 맞게 그 내용을 다시 실행시켜준다.
            //쉽게말하자면 ,스크린을 자동으로 클릭해주는 코드다!//셋타임함수가 실행되면 이코드가 실행되고 자동으로 클릭해주면 다음으로 넘어가겠죠 즉, (클릭이벤트가 자동으로 실행됨! 내가 마우스로 클릭안해도!)
            //이 코드가 없으면 당연히 셋타임함수만 실행되고 화면에서는 아무것도 변화가없음,,이코드를 넣어줘야 자동으로 클릭되게 해줘서 밑의 코드로 넘어가서 화면도 바뀜!
            //그리고 이코드가 없으면, 그냥 셋타임함수종료되고 아예 이벤트가 종료된다. 즉 빨간색화면에서 멈춰있음,,왜냐면 
            //그니까 스크린.click() 이거는 눈속임? 코드다 그니까 그냥 일정시간이후 알아서 클릭을 해주니까 다음 화면으로 넘어가는것일뿐이다.
            //시작시간=new Date(); //31 이 위치는 셋타임함수인데 랜덤한시간이후 클릭을하면(스크린.click()이 클릭을 자동으로 해주니까..)코드가 실행되고, 이 시간이 기록된다.
            //참고로 시작시간의 실행순서는 밑에코드가 다 실행되고 종료된뒤, 시작시간이 실행됨.
        },Math.floor(Math.random()*1000)+2000); //27 이 부분이 랜덤한 시간으로 설정이 되어야한다.//29 추가로 재미를위해 2000~3000사이로 재설정
        //28 메스.랜덤하면 0부터 1사이의 랜덤한 소수가 나오고, 곱하기 1000 하면 0부터1000사이의 랜덤한 수가 나온다.
    }else if(스크린.classList.contains('ready')){ //8 빨간상태/준비상태 (참고로 이렇게 if문으로 다 분기처리 를해서 기능별로 나눠놓는게 좋다.)빨간색일때 클릭을하면 밑의 코드가 실행되요~(여기서는 자동으로클릭해주는 코드가있으니 알아서 초록색으로넘어감)
        if(!시작시간){ //38 부정클릭(미리클릭하는걸방지)을 방지하기위해 if문을 걸어준다.//42 시작시간변수에 값이 false(undefined null NaN 0 false ''(빈문자열)) 일때 실행이 되는 기능!즉, 위에 셋타임함수를 거친 시작시간의 변수는 값이 들어가있는 상태이므로 !시작시간은 값이false인상태이므로 여기조건에 만족하면 아래코드가 실행됨!
            //console.log('급하게눌렀을때의 시작시간 값',시작시간);
            clearTimeout(타임아웃); //40 그리고 여기다가 타임아웃변수를 넣어줌으로써, 조건에 만족할시 셋타임아웃함수(타임아웃변수를)를 여기서 실행이 안되게 해제시켜주는 기능이다.
            // !시작시간 이코드에 대해 설명을 하자면 , 처음 전역스코프에 시작시간변수에는 값이 undefined이다. 즉,false인상태이지만, 셋타임 함수를 거쳐서 (자동실행되서) 이미 시작시간의 변수에 값이 들어가있는 상태가 되므로 true인 상태이다.
            //그래서 빨간색일때 클릭을하면, 셋타임함수는 실행되지않고 바로 다음코드가 실행되므로 
            //여기서 클리어타임아웃을 안해주면, 어떻게 되냐면 ~
            // 내가 임의로 빨간색일때 클릭을해서 화면을 넘겼다고해서 셋타임아웃이 실행이 안되는게 아니다. 실행은 된다 .
            //결국 일단 셋타임아웃은 정상대로 실행이 된다. 그래서 막 왔다갔다 되서 결국 초록색으로 넘어간다. 
            //그래서 클리어타임아웃을 해줘야 아예 셋타임아웃이 실행을 멈춘다.
            스크린.classList.remove('ready');
            스크린.classList.add('waiting'); //다시 아쿠아색 대기상태.
            스크린.textContent='너무 성급하시군요! 다시 클릭 해주세요!';
         }else{
            //console.log('원래 정상적으로 기다렸을때의 시작시간 값',시작시간);
            스크린.classList.remove('ready');
            스크린.classList.add('now'); // 옐로우그린상태 즉, 이상태서 클릭을 하면 된다.
            스크린.textContent='클릭하세요!';
        }
    }else if(스크린.classList.contains('now')){ //초록색일때 클릭을하면 밑의 코드가 실행되요~(이코드는 초록색화면일때 클릭을하면 끝시간이 기록되고, 시작시간,끝시간이 초기화되고,기록에 데이터가넘어가고 다음 아쿠아색 화면으로 넘어간다.)
        끝시간=new Date(); //32 이 위치는 클릭이후 바로 종료시간을 저장해 놓은 용도임
        console.log('반응속도',끝시간-시작시간,'ms'); //33 그래서 여기로그에 찍어본다 
        기록.push(끝시간-시작시간);
        console.log('기록',기록); //36 로그로 찍어본다. 그리고 팁으로 평균구하기는,, 뭐 로그에서 (기록[0],기록[1],기록[2])/3 하면 평균도 구할수있다.
        시작시간=null;//42 한번 다 돌았으면 시작시간을 초기화해준다.
        끝시간=null;//43 한번 다 돌았으면 끝시간을 초기화해준다.
        스크린.classList.remove('now');
        스크린.classList.add('waiting'); //다시 아쿠아색 대기상태.
        스크린.textContent='클릭해서 시작하세요!';
    }
});

//37 그리고 처리해줘야할 이슈는 만약 성질급한사람이 빨간색(대기상태)일떄 눌러버리면 안되니까, 화면이 넘어가지않고 고정되있도록 처리해줘야한다.

//메모> 비동기는 호출스택에 들어갔다가 종료된다.

//44 ! 느낌표를 설명하자면 !느낌표는 어떤상태이냐면 그 반대의 상태를 의미한다. 그 값이 원래 true면 !느낌표를 붙이면(적용하면)false로 적용하는게 되고,
// 그 값이 원래 false 이면 !느낌표 붙이면 true 를 적용시킨다.
//즉, !a 이면 a의 값이 현재 true이면 false 일때 라는 의미이고, a의 값이 현재 false이면 true일때 로 적용된다.
//여기서 값이 false일때의 조건은 바로..
//undefined null NaN 0 false ''(빈문자열) / 즉 이 6개 인 상태가 바로 false인 상태이다. 여기 6개중 하나라도 속하면 그 값은 false의 값이다 라고 부르는것이다.
//즉, !이게 들어가면 저 6개중 하나의 상태라도 되는 값이 저런 상태인걸 의미한다.
// 예를들어 위의코드중 !시작시간 이거는 ,저때 시작시간의 값이 현재 무슨값이냐라는것이다. 시작시간은 현재 undefined 가 들어있으니 false 라고 말할수있다.
//왜냐면 저기 보면 var 시작시간; 이렇게 되어있는데 저 시작시간의 변수에는 지금 undefined가 들어가있다 즉, var 시작시간 = undefined 인 것이다. undefined 가 생략된거로 보면된다.여튼..
//즉 시작시간에 undefined 가 들어있으므로 false의 값이다 라는것!
//그리고 또 밑에 코드중 시작시간이 null로 되있는것도 이것도 false 로 보면된다.
//근데 그게 중요한게 아니라, !느낌표는 반대의 상태를 말하는 것이다.
//즉 true 일때는 false 로 , false일때는 true로 ~

//45 !시작시간 의 코드해석
// 만약 시작시간에 값이 들어가있지 않다면(false값(즉,undefined null NaN 0 false ''(빈문자열))이렇게 되는거고,
//만약 시작시간에 값이 들어가 있다면 true값이 되는거다.
// 즉 기작시간의 값이 들어있냐(true) 안들어있냐(false) 에 따라서 !느낌표를 달았을때 어떤의미인지 바뀐다는것이다. 

//일단 모든 코드는 순차적으로 즉, 위에서 아래로 실행된다. 

//스크린.click 은 뭐냐면 이 코드는 클릭이벤트를 다시 실행시켜주는 코드이다.즉 스크린.addEventListener('click',function(){  이부분에서 클릭저 함수를 실행시켜줌으로해서, 지금 화면의 클래스의위치에 맞게 그 내용을 다시 실행시켜준다.
//쉽게말해서 내가 마우스로 클릭을 하는거를 코드로 자동으로클릭해라 하는 코드다.
//즉 내가 직접 손으로 마우스 안눌러도 저코드넣으면 클릭되는것,,,이게 다다...
//즉, 특정시간이후에 셋타임함수가 실행되고 자동으로클릭해주는코드(스크린.click())이 실행되서 화면이 바뀌고, 그 동시에 시작시간코드가 실행되서 시간이 기록된다.
//그리고나서 클릭을 또 마우스로 해주면 화면이 클릭이벤트에 if문의 조건에따라서 (코드에따라) 다음화면으로 넘어가는것뿐이고, 끝시간코드도 실행되면서 시간이 또 기록된다.

//참고로 클릭이벤트는 비동기함수인데, 이 비동기함수는 실행후종료가되면 그안에 변수에 저장되건 뭐건 싹 날려버린다.
//즉 저장이 안되는것이다.
//저위에 클릭이벤트에도 if문 조건이 3개로 쪼개져 있고, 각각 실행될떄마다 실행되고 종료되고 싹 날려버리고 이런식이다.즉 호출스택에서 하나처리하면 비워지고, 이런식이다.
//그래서 뭘 저장하려면 전역스코프에 미리 변수를 선언해놓고, 비동기안에서 처리한 데이터는 전역스코프의 변수에 저장시키는 방식으로 해야한다.
