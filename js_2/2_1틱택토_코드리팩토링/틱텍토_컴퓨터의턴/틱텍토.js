var 바디 = document.body;  // 바디불러오고
var 테이블 = document.createElement('table'); // 테이블불러오고
var 줄들 = []; // 빈 배열만들러서 줄들로 해놓고
var 칸들 = []; // 빈칸 저장을 여기다 했음! //빈 배열만들어서 칸들로 해놓고
var 턴 = 'X'; // 턴은 X라는 문자열이고
var 결과 = document.createElement('div'); // 결과는, html에서 div를 새로생성해서 만들어 넣는거고
//var 다참;

//var 몇줄 = 줄들.indexOf(이벤트.target.parentNode); // 이렇게 애네를 전역스코프변수로 배내는 방법이 있고,
//var 몇칸 = 칸들[몇줄].indexOf(이벤트.target); // 마찬가지,,,..///

//참고로 배열에서만 indexOf를 쓸수있다.
//배열이 아닌 애들한테는 indexOf 를 못쓴다는거!!!

function 결과체크(몇줄,몇칸){ // 이렇게 몇줄 몇칸을 괄호 안에 매개변수로 넣는 방법이 있다.
    //세칸 다 채워졌나?
    
    //var 몇줄 = 줄들.indexOf(이벤트.target.parentNode); 
    //var 몇칸 = 칸들[몇줄].indexOf(이벤트.target); 

    var 다참 = false;
    
    //가로선 검사
    if( 
        칸들[몇줄][0].textContent === 턴 && 
        칸들[몇줄][1].textContent === 턴 && 
        칸들[몇줄][2].textContent === 턴 )
        { 
        다참 = true;
        };
    //세로줄 검사
    if(
        칸들[0][몇칸].textContent === 턴 &&
        칸들[1][몇칸].textContent === 턴 &&
        칸들[2][몇칸].textContent === 턴 )
        {
        다참 = true;
        };

    //대각선 검사
    // if(
    //     몇줄 - 몇칸 === 0 //왼쪽에서 오른쪽으로 대각선 검사 필요한경우
    // )
    //{
        //그냥 대각선 검사는 매번 하는게 더 낫다.
        if(
        칸들[0][0].textContent === 턴 &&
        칸들[1][1].textContent === 턴 &&
        칸들[2][2].textContent === 턴 
        )
        {
            다참 = true;
        };
    //}

    // if(
    //     Math.abs(몇줄 - 몇칸) === 2 //오른쪽에서 왼쪽으로 대각선 검사 필요한경우
    // )
    //{
        if(
        칸들[0][2].textContent === 턴 &&
        칸들[1][1].textContent === 턴 &&
        칸들[2][0].textContent === 턴 
        )
        {
            다참 = true;
        };
   // }
   return 다참; //사실은 리턴값을 다참변수로 주는 의미는 그냥 이결과체크함수의 리턴값은 true/false 이다를 나타내는것이다 
   //그렇기떄문에 이 변수를 밑에서 재사용하는게 절대아니다 그냥 함수의 결과값만 리턴해준다고 생각하고, 밑의 다른 함수와는 스코프가 다르니 전혀 상관이 없다. 
   //그냥 밑의 함수에서는 그함수에서 이함수를실행시켜 나오는 리턴값만 받아 따로 저장해둬서 그값이 뭐 true든 false든,, 그 값을 재사용하는거다. 
   //즉 이름이 같다고해서 아 함수끼리 스코프가 연결이된는구나가 절대아니다. 그냥 결과값을 저장해서 쓰는것일뿐이다.
   //제로초의 말은 그냥 "다참은 칸이 xxx인지 ooo인지 물어보는코드임.//여기 함수 리턴값으로 다참을 해주면,,밑에서 다참을 받아 쓸수있다."라는말은"뭐 얼추 맞긴한데 받아쓰는건 아니고 그냥 그 결과값을 저장해서 쓰는것일뿐임!
} //////////////여기까지 결과체크함수!

function 초기화(무승부){ // 초기화
    if(무승부){
        결과.textContent='무승부';
    }else{
        결과.textContent=턴+'님이 승리!';
    }
    //결과.textContent = 턴 + '님이 승리 하셨습니다'; // 턴+텍스트문자를 결과에 넣어주고 결과 출력
    //console.log(턴 , '님이 승리하셨습니다');

    //초기화 코드
    setTimeout(function(){ //셋타임함수 시작
        결과.textContent='';
        칸들.forEach(function(줄){
            //console.log('줄!!!',줄);
            줄.forEach(function(칸){
                //console.log(칸);
                칸.textContent =''; // 애네들이 기본적으로 false값이다. ''빈칸!이니까!
            });
        });
        턴 = 'X';
    },1000);//여기까지 셋타임함수끝
};// 여기까지 초기화 함수끝!

var 비동기콜백 = function(이벤트){ //칸을 클릭했을때! 
    // console.log(이벤트.target);
    // console.log(이벤트.target.parentNode);
    // console.log(이벤트.target.parentNode.parentNode);
    //console.log(이벤트.target.children);
    
    if(턴 === 'O'){ // 이코드는 일단 O일 경우에는 아무것도 실행이 안되는 즉,이밑코드로 넘어가지않는 코드이다. 즉 O일때는 컴퓨터가 실행되고있는중이므로 클릭이벤트를 또 누를경우를 방지하는 코드임!
        return;
    }

   var 몇줄 = 줄들.indexOf(이벤트.target.parentNode); // 클릭했을때 몇번째줄인지 알아내는코드 //내가 클릭한 칸이 몇번째 줄인지?
    // console.log('몇줄',몇줄);

   var 몇칸 = 칸들[몇줄].indexOf(이벤트.target); // 클릭했을때 몇번째칸인지 알아내는코드 // 내가 클릭한 칸이 몇번째 칸인지?
    // console.log('몇칸',몇칸);

    if(칸들[몇줄][몇칸].textContent !== '' ){ // 칸이 이미 채워져있는가? // 그리고 남이 이미 클릭한 칸인지 분별하는것!즉,칸이 비워져있는지,아니면 누가 클릭했는지?
        console.log('빈칸이 아닙니다');
    }else{ //빈칸이면 // 빈칸을 클릭 했으면, 밑에보면 그 칸에다 x나 o표시 해주고 
            console.log('빈칸 입니다');
            칸들[몇줄][몇칸].textContent = 턴; 
        
            var 승리여부=결과체크(몇줄,몇칸);  //이거는 사실 그냥 함수를 여기서 실행시켜 얻는 결과값을 저장하는 것일뿐이다.//다찼으면 결과체크 해주고,즉 이렇게 다참이라는 변수를 만들어서 다참으로해주면 위에 리턴값이 다참이기때문에, 여기다참에 리턴값을 받아 쓸수있다.
        
            //모든칸이 다 찼는지 검사
            var 후보칸 = [];
                        칸들.forEach(function (줄) {
                        줄.forEach(function (칸) {
                        후보칸.push(칸);
                            });
                        });

            후보칸 = 후보칸.filter(function (칸) { return !칸.textContent });            

            //다 찼을경우
            if(승리여부){ //이겼을 경우
                초기화(false);//여기는 원래false인데 비워둬도된다.비워두면 undefined니까 undefined는 if문 안에 들어가면 자동으로 false 이기때문이다 // 다 찼으면, 다찻으니까 이제 초기화 하고~ //위에 함수를 따로 만듬!
            }else if(후보칸.length === 0){  //칸을 더이상 선택할수 없을때//칸을 더이상 선택 할수 없다.
                초기화(true);
            }else{ //다 안찼을경우
                        if(턴 === 'X'){ 
                            턴 = 'O';
                        };
                        
                        // 여기부터 컴퓨터가 임의로 넣는 턴 시작코드!!>>>>>>>
                        setTimeout(function(){ // 다안찻으면,1초뒤에 컴퓨터의 턴으로,즉 이 부분이 컴퓨터의 턴을 만드는 부분! //참고로,예전 틱택토코드에서 추가를 한건 이부분 밖에 없다.
                        console.log('컴퓨터의 턴 입니다');
                        //여기에 들어갈 코드는 
                        //빈칸중 하나를 고른다. 그다음
                        
                        //후보칸 = 후보칸.filter(function (칸) { return !칸.textContent }); //여기 후보칸은 쉽게말해서 아무도 안고른 칸들 즉,빈칸이 담긴다. 즉, 빈칸을 골라내는 코드임!// '', 0, NaN, undefined, null, false //애네들은 if문안에 넣으면 false가 되는 값들임!
                        //지금 칸.textContent 애가 뭐냐면, filter함수입장에서는 true인 값이다 ,즉 칸.textContent 안에는 지금 뭔가 값이 들어있다는 뜻이다. x 가 들어있던가. 
                        //그런데 !칸.textContent 이렇게 하면 느낌표 주면 false가 되버리면서 빈칸만 딱 필터되어 골라지는것이다.!! 그니까 '', 0, NaN, undefined, null, false 애네들만 골라라 라는 뜻이다.!
                        //후보칸에는 아무도(나나 컴퓨터가 안고른,,) 안고른 빈칸들이 담긴다. // 그리고 !칸.textContent가 false인 값('', 0, NaN, undefined, null, false)이 아닌거를 말함 // 즉, filter매서드는 리턴값이 true 이냐 false이냐에 따라 필터가 되냐 마냐로 결정된다. 즉 리턴값이 true면 true인 애들만 걸러내고 false면 false인 애들만 걸러낸다.
                        
                        var 선택칸=후보칸[Math.floor(Math.random()*후보칸.length)];// 이코드는 후보칸 갯수중에 랜덤으로 하나를 선택하라는 코드이다.
                        선택칸.textContent=턴;

                        //컴퓨터가 승리했는지 체크하는 코드!
                        var 몇줄 = 줄들.indexOf(선택칸.parentNode);
                        var 몇칸 = 칸들[몇줄].indexOf(선택칸);
                        var 다참1=결과체크(몇줄,몇칸); //여기 매개변수로 넣어주고
                        // 이렇게 다참이라는 변수를 만들어서 다참으로해주면 위에 리턴값이 다참이기때문에, 여기다참에 리턴값이 적용된다.
                        //다 찼을경우
                        if(승리여부){ //컴퓨터가 이겼을 경우~
                                    초기화();
                                };
                            //턴을 나한테 넘긴다.
                        턴 = 'X';
                        console.log('컴퓨터의 턴 입니다.');
                    },1000); //여기까지 컴퓨터가 임의로 넣는 턴 코드 끝>>>>>>>>>>>
            };
        };
    }; ///////////////// 여기까지 비동기 콜백함수

    //함수로 만들어주면, 어떤 흐름으로 되어가는지 빨리 파악을 할수가 있다.

    // 여기서 for문 이 도는데, 내용은, 3번 도는데 돌 동안 뭘 하냐면, 
    //tr 을 새롭게 생성하여 줄이라 하고,
    //칸들에 뭘 넣는데, 빈 배열을 넣고
    //줄들에 뭘 넣는데, 줄을 넣으면 화면에 가로로 3개의 줄이 그려지고 그게 줄이되는거다.
    //그리고 안에 또 for 문이 있는데, 이거는 가로로3개의 칸을 채워넣는거다.
    //td로 칸을 생성한후
    //줄에 칸을 묶어준다. 그럼 3개의 줄들에 칸들이 3개가 달린다.
    //칸들에는 칸을 넣어주는데, 0 1 2 이렇게 되야되니까 저렇게 식을넣어 구현해준다.
    //각각의 칸 마다 는 클릭이벤트를 걸어준다.
    //그런뒤 테이블에다 줄을 묶어준다.
for(var i = 1 ; i <= 3 ; i += 1){
    var 줄 = document.createElement('tr'); // tr 과 td 는 이제, 3x3으로 만드는 재료이다.
    칸들.push([]); // 그리고 칸들에 다시 배열을 추가함!
    줄들.push(줄);
    for(var j = 1 ; j <= 3 ; j += 1){
        var 칸 = document.createElement('td');  
        줄.appendChild(칸);
        칸들[i - 1].push(칸);
        칸.addEventListener('click',비동기콜백); // 칸을 클릭했을때 비동기콜백 함수가 실행되도록!
    }
    테이블.appendChild(줄);
}

바디.appendChild(테이블);
바디.appendChild(결과); // html화면에 결과를 어펜드 차일드로 보여주고, 붙여주고!

console.log('칸들',칸들,'줄들', 줄들);
