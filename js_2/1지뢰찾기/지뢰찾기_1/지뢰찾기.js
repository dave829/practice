//1.먼저 지뢰를 까는 작업(연습을)을 한다.
//2.지뢰찾기 모양이 2차원 배열이니까
//3.그래서 2차원배열을 쓸껀데,
//4.그리고 지뢰를 랜덤하게 설치하니까, 지뢰를 랜덤하게 설치하는 작업해야되고
//5.그리고 지금 그냥 쿼리셀렉터로 벨류값 가져오면 문자로 가져오는데, parseInt로 감싸주면 숫자로 가지고온다.
//6. 참고로 크롬 콘솔에서 숫자는 파란색으로 뜬다. 문자는 걍 검은색으로 뜨고 

var tbody = document.querySelector('#table tbody'); //58> 여기에 티바디를 글로벌 영역으로 옮기므로인해 이제 갖다쓸수있게되었다.

var dataset = []; //13.일단 글로벌에 빈 배열하나 만들어주고 밑에 for문안에서 // 글로벌에 만들어야함!!

document.querySelector('#exec').addEventListener('click',function(){

        //80> 블럭 내부 먼저 초기화 코드
        tbody.innerHTML = ''; //81> tbody의 내부코드들을 지워버림 // innerHTML은 그태그의 화면을 컨트롤하는것

        //7. 먼저 가로,세로,지뢰개수 파악
        var hor = parseInt(document.querySelector('#hor').value);
        var ver = parseInt(document.querySelector('#ver').value);
        var mine = parseInt(document.querySelector('#mine').value);
        //8.console.log(hor,ver,mine);
        
        


     //26.여기에 붙여넣자 로또추첨기코드 //아래코드는 여기에서 지뢰위치 뽑기 코드임!!!
        var 후보군 = Array(hor * ver) //27. 가로 곱하기 세로가 칸의 갯수잖아요 , 그래서 가로x세로 만큼 해서 그만큼 빈배열을 만들고~
            .fill() //28. 그 빈배열을 undefined로 채운다. 그니까 10 * 10= 100개 니까 100개의 배열을 다 fill()해서 undefined로 만들어주고~그럼 언디파인드가 100개있는 배열이되는거임 그리고~
            .map(function(요소,인덱스){ //29. 그 배열을 map이 1:1로 짝지어 주는 부분이다. 인덱스가 0 부터 99까지이니까 
            return 인덱스;  //30. 여기서 그냥 0 부터 99까지의 값으로 처리하는게 더 나을것같다. // 그럼 0부터 99까지로 세팅이 되는거다.
             });//52> 30 줄 -> 이부분 수정!!!
            //console.log(후보군);//31. 1부터100까지 들어간거 콘솔찍어봄
        
        var 셔플 = []; //32> 여기 셔플에는 지뢰의 위치들이 최종적으로 담기게된다.
        
        while (후보군.length > 80 ){  //38> 여기서 80 으로 하면 80보다 큰 숫자만 걸려서 나가게되므로 20개만 뽑히게된다.
             var 이동값 = 후보군.splice(Math.floor(Math.random() * 후보군.length) , 1 )[0];
             셔플.push(이동값); 
        }
        //console.log('지뢰코드',셔플);//33> hor ver으로부터의 랜덤값 생성  
        //34> 이 셔플 방법을 피셔예이츠 셔플 이라고 한다.(피셔랑예이츠가 만들어서그렇다고한다...)
        //35> 여기서 나온 랜덤값 1부터 100중에 앞에 20개(랜덤한숫자임..)를 뽑아서 이 빈칸에다가 지뢰로 심으면 되겠죠! 
        //36> 그리고 사실 20개의 랜덤한 값만 뽑으면 되는데 , 100개 다 뽑으니 성능 낭비가 되니까 20개만 뽑도록 설정해주자
        //37> 그래서 저 위에 후보군.length 부분을 수정하면된다.
        //39> 그래서 지금 셔플 에 지뢰의 위치가 딱 들어있고(랜덤한 위치),
        //40> 그리고 밑에 코드보면 테이블도 구현한 상태이다. 그래서 저 테이블에 데이터만(지뢰를) 넣어주면 화면에 출력되겠죠
        //41> 이제 지뢰를 저 테이블에 넣어주자
        


    //9.아래는 지뢰테이블 만들기 코드임!!!

        // 10.그리고 그전에 화면이랑 데이터 연결을 해야되는데요 그니까 화면이랑 데이터를 항상 싱크를 맞춰줘야된다
        //11.그니까 데이터를 화면이 시뮬레이션 해야되는데,,,
        //12.데이터를 먼저 ,,,2차원배열이죠, 2차원 배열을 먼저 만들고 ,이거를 다시 화면에 반영하는 순서임를 작업하는게 좋다
       

        //17.테이블에 티바디에 화면을 만들꺼다.
        

        //18.그다음 그리고 가로 세로 10개씩 만들어야 되니까...
        //19.2중 반복문을 써서만들자
        //20.세로먼저 만들고 가로~
        //21.tr이 세로니까 , tr을 먼저 만들어야 tr안의 td를 그다음으로 넣을거니까...
        for(var i = 0; i < ver; i += 1){ //13.세로로 일단 10줄 만들고 //일단 세로먼저 ,tr이 세로
            var arr =[]; // 14.여기도 배열하나만들어주고 애는 데이터셋배열안에 들어갈 아이임
            dataset.push(arr); //15. 데이터셋 빈배열안에 arr빈배열을 넣어라라는 코드 그러면 반복문에따라 돌겠죠
            var tr = document.createElement('tr');
            tbody.appendChild(tr);
                for(var j = 0 ; j < hor ; j += 1){ //13.가로로 10줄 
                    arr.push(1); //16.그리고 arr배열안에 뭐가들어갈지 넣으면 출력이된다 지금은 1을넣었죠,,
                    var td = document.createElement('td'); //이부분이 td생성부분!! //td는 한칸을 의미한다.
                    //65.1> 이부분에 이벤트리스너를 바로 달아준다 , 즉 컨텍스트메뉴를!!!
                    td.addEventListener('contextmenu',function(e){ // 여기서 e는 컨텍스트메뉴 즉, 오른쪽클릭을 하는 이벤트 자체를 넘겨받아 파라미터로 받은거다.
                        //console.log('오른쪽클릭'); // 65.2> 하고 밑에 코드는 삭제해준다.
                        //69> 이제 여기에 깃발이랑 물음표 표시를 만들어주면된다.
                        e.preventDefault();
                        //e.target(); // 70> target은 실제로 이벤트가 발생하는 그 태그를 말한다. 여기서는 td태그를 말한다./ 즉 그 엘리먼트 , e가 그 오른쪽클릭했을때 선택된 그 태그를 가르키는게 target이다.
                        var 부모tr = e.currentTarget.parentNode; // 71> 기본적으로 커런트타겟을쓰는게 안했갈린다. 커런트타겟은 기본적으로 이벤트리스너를 단 대상을 가르킨다 즉, tr에 달았으니까 tr를 가르킨다, 그냥 타겟은 이벤트리스너를 발생시킨 태그만 가르킨다
                        var 부모tbody = e.currentTarget.parentNode.parentNode; //71> 지금 이코드는 오른쪽클릭했을때 애가 몇번째 줄 몇번째 칸인지 위치를 파악하는코드다. 그 위치를 알아야 거기다 물음표나 깃발을 넣지요.
                        //console.log(부모tr,부모tbody);
                        //e.currentTarget , e.target;
                        var 칸 = Array.prototype.indexOf.call(부모tr.children,e.currentTarget); //72>누른게 무슨칸인지 좌표뜸
                        var 줄 = Array.prototype.indexOf.call(부모tbody.children,부모tr);//73>누른게 무슨줄인지 좌표뜸
                        //console.log('칸',칸,'줄',줄);
                        //console.log(td); //74> 지금 td 찍어보면 위치가 이상하게 나옴 왜냐면 클로져 문제가 발생함,, 코드수정이 필요함.// 여기서 클로져는 td가지금 원래는 태그로치면 한 부분인데 그래서 td를 위에보면 포문안에있는 td를 클로져로 참조하고있는거고, 그래서 포문을 돌아서 젤 끝부분이 선택된거다. 
                        //console.log(줄);
                        // e.currentTarget.textContent = '!'; //74> 이코드는 화면에서 보여질 코드
                        // dataset[줄][칸] = '!'; //75> 데이터쪽에서 보여질 코드
                        // //76> 항상 웹프로그래밍할때는 화면과 데이터를 일치시켜줘야한다!!
                        //77> 여기서 물음표랑 느낌표 빈칸을 번갈아가면서 넣어줘야되니까 if문으로 짠다.
                        if(['','X'].includes(e.currentTarget.textContent)){
                             e.currentTarget.textContent = '!';
                             
                        }else if(e.currentTarget.textContent === '!'){
                            e.currentTarget.textContent = '?';
                            
                        }else if(e.currentTarget.textContent === '?'){ //79> 여기서는 데이터를 비교해서 1일경우나 X일경우로 해서 조건을 그렇게 넣고 하면된다
                            if(dataset[줄][칸] === 1){ //78> 여기서 숫자 1 을 넣어주는이유는 , 지금 여기가 데이터쪽이니까 빈칸을 넣으면 안되고 데이터에서 빈칸은 1을 넣어주면된다.
                                e.currentTarget.textContent = '';
                            }else if(dataset[줄][칸] === 'X'){
                                e.currentTarget.textContent = 'X';
                            }
                        }

                        

                    });
                    tr.appendChild(td);
                    //td.textContent=1; //22.테스트로 1넣어봄

                    //82> 아래코드는 클릭했을때 주변지뢰 갯수 알려주는 기능 코드임!
                    td.addEventListener('click',function(e){  //83> td는 한칸이니까 한칸을 눌렀을때의 이벤트를 생성하는거임!
                        var 부모tr = e.currentTarget.parentNode; 
                        var 부모tbody = e.currentTarget.parentNode.parentNode; 
                        var 칸 = Array.prototype.indexOf.call(부모tr.children,e.currentTarget); //내가 지금 누른게 무슨칸인지 위치뜸
                        var 줄 = Array.prototype.indexOf.call(부모tbody.children,부모tr);//내가 지금 누른게 무슨줄인지 위치뜸
                        //e.currentTarget // 현재 클릭한 칸 , 이벤트리스너를 단 대상태그 즉,td 일꺼임! 
                        if(dataset[줄][칸] === 'X'){
                            e.currentTarget.textContent = '펑!';
                        }else {
                            var 주변 = [ //86> 배열을 변수로 넣어줌! //이코드들는 클릭한 주위 8칸의 위치를 나타냄
                                
                                dataset[줄][칸-1],dataset[줄][칸+1],
                                
                            ];
                                //87> 여기서 조건문은 왜쓰냐면, 지금 코드가 테두리쪽을 클릭하면 에러가 나므로 그걸 처리해주려고 조건문을 쓴다.
                                //88> 그래서 if문을 2개로 나누어서 윗줄에러처리부분, 막줄에러처리부분 이렇게 2개의 if문이 들어가고, concat을 써서 주변변수에 포함된 중간위치코드를 합쳐준다. *concat은 배열끼리 합쳐 결국 문자열을 합쳐줌!
                                //88.1> 그니까 쉽게말해서 위를 처리하는코드 아래를처리하는코드 이렇게 둘로나누어서 하면 에러가안나잖아...그렇게해서 다 합쳐버리면되니까.
                                //91> 일단 if문이 2개인거는 따로처리되는게 아니라 첫번째 if문 값을 가지고 변수 주변에 저장하고, 밑에 if문 값을 또 변수 주변에 저장해서 출력하는데,
                                //92> 첫번째 if문은 조건이 어떻게되있냐면 이 줄이 원래 0부터9까지 인덱스인데, -1 부터 8까지 니까 -1은 없으니까 처음은 실행이안되고 1부터실행되겠지....
                                //93> 두번째 if문은 조건이 0~9까지 인덱스라면, 1부터 10까지니까 이거는 처음은 실행이 되고, 마지막 부분은 실행이 안되지 10이라는 인덱스는 없으니까...
                            if(dataset[줄-1]){ // 이거는 결론적으로 윗칸은!! 실행이 안되! 즉, 윗칸 방지용, 아랫칸들만 찾는코드, 왜냐면 줄-1 이니까 만약 0-1 이면 -1이니까 여기 -1인덱스는 없으니까 
                                주변 = 주변.concat([dataset[줄-1][칸-1],dataset[줄-1][칸],dataset[줄-1][칸+1]]); //89> concat할때 한 배열로 묶어준다. // 윗줄에러부분처리
                            }
                            if(dataset[줄+1]){ //이거는 결론적으로 아랫칸은!! 실행이안되!즉,아랫칸 방지용, 윗칸들만 찾는코드,왜냐면 줄+1 이니까 만약 0+1이면 1이니까 실행되고 쭉,,가서 9+1은 10이니까 10은 여기인덱스에 없으니까 실행안되는거야/그래서 위에칸 누르면 이코드 실행되고 ,그리고 중간코드들은 당연히 다실행되고 ,그러면 아래칸만 이코드가 실행이안되!
                                주변 = 주변.concat([dataset[줄+1][칸-1],dataset[줄+1][칸],dataset[줄+1][칸+1]]); //90> 아랫줄에러부분처리
                            }
                           
                            console.log(주변); // 86> 주변값은 if문을거친 값들이 다 합쳐져서 최종적으로 나온다 , concat을 썻기때문이다.
                            
                            e.currentTarget.textContent = 주변.filter(function(v){  //84> 필터함수는 배열에서 필터링하는 거 , 
                               return v === 'X' //85> 배열의 요소가 'X'인 거를 찾아주는거 ,
                            }).length;
                           
                            
                            //e.currentTarget.textContent = ''; //84> 여기다 숫자를 넣어줘야되는데요.
                        }
                        
                        

                    });


                }
        }
        //console.log(dataset); //25.그럼 여기서 콘솔찍어보면 2차원 배열이 딱 나오죠
        
        //42> 아래코드는_지뢰심기코드


    //25. 위 코드는 일단 데이터셋 부분은 2차원배열을 생성한거고, 저 티바디 저부분은 화면에 출력될 부분입니다.
    //25. 지금 칸이 다 만들어졌는데 저 칸이 0부터 99까지 있겠죠 칸이 , 0부터 시작하니까 99까지~
    //25. 10x10 은 100이고, 0부터 시작하면 99까지죠
    //25. 99까지 있으니까, 0 부터 99까지 중  20개를 뽑으면 되겠죠
    //25. 0부터 100가지 중에 20개 뽑기!
    //25. 이거를 어떻게 하냐면 ,로또추첨기 시간때 배웠던 코드이다. 그 코드를 가지고오자!
    //25. 그래서 이제 1부터 100해서 지뢰의 갯수만큼 랜덤하게 숫자를 뽑을꺼다.

    //43> 지금 "셔플"에 지뢰위치들이 담겨있잖아요(랜덤값20개),개네들을 이제 화면에다가 심어 봅시다.
    //44> 지뢰 이미지를 구해서, 아니면 그냥 x표시로 해봅시다.
    //45> 콘솔에 첫번째 보시면 ex) 55가어디일까요? 저희는 분명 2차원 배열을 했는데 그럼 55가 어디에들어가야될까요?
    //46> 즉 , 저기 화면의 박스보시면, 12345,,,이렇게 가죠 그래서 55는 6번째칸 5째줄 이렇게 위치해야하는거죠, 그런식으로 다 위치가 있으니 넣으면되겠죠!
    //47> for문으로 넣어봅시다.

    for (var k = 0;k < 셔플.length;k++){ //지뢰심기코드
        var 세로 = Math.floor(셔플[k] / 10); //48>예) 60라면... 여기서는 결과값은 7=6 , 자바스크립트에서 0부터 세니까 
        var 가로 = 셔플[k] % 10; //49> 여기서 % 퍼센트는 나머지이다. 결과값은 =0  ,,위치를 지정해주는 공식?이다.
        //console.log('오류있나?',세로,가로);
        tbody.children[세로].children[가로].textContent = 'X'; //50> 애는 화면 //인덱스에 위치값 전달,,, 넣어줌, 그니까 티바디에 칠드런하면 티바디안에 tr이 유사배열로나오는데 그 tr을 가르키는거다된다 즉 세로가 tr 가로가 td가 되고 거기다 x를 넣은거고 ,또, 태그에서는 children으로 자식 태그들에게 접근할 수 가있다. 
        dataset[세로][가로] = 'X'; //51>//애는 따로관리하는2차원배열데이터//항상 화면이랑 데이터랑 일치 시켜야된다.
        }; 
     //console.log('지뢰심기',dataset);


});

// 53> 그러면 0부터 99까지의 번호가 세팅이 되는거고, 이제 지뢰심기 코드를 수정해보면,,,
// 54>  즉, 세로는 실제위치가 3이라면 2로값이 나오게 코드를 짜면, 0 1 2 하면 실제위치가 3이 되니까 그렇게하고, 가로는 그냥 저렇게 하고,해서 지뢰를 심어봤다.
// 55> 그리고 또 추가해야할 기능은 첫번째 클릭을 할시 지뢰가 선택 안되게 구현해야되고, 또 우클릭하면 깃발 표시나 물음표 표시가 되게 구현해야되는데, 그 거는 온컨텍스트 메뉴로 구현한다.

//57> 일단 tbody가 지금 저기위에 코드를 보면 티바디는 저 클릭이벤트안의 함수안에 있으므로 지금 밑에 코드의 티바디에 영향을 미치지않는다.그니까 서로 다른 티바디이다. 그래서 이 티바디에 접근을하려면 같은 티바디로 즉,같은스코프에 넣고 쓰려면 전역/글로벌로 옮겨야한다.그래서 맨위에 상단으로 옮겨졌다.
//59> 이제 깃발 표시를 하는 기능을 만들어보자.
//60> 아래 클릭이벤트코드는 모든칸들에서 반복문으로 돌려야 적용을 할수있으니까. 쿼리셀렉트올하고 포이치를 쓴다. 그리고 그안에 클릭이벤트를 넣고함수를넣는거다
//61> 지금 코드는 모든 칸들에 컨텍스트메뉴 이벤트를 붙이는거다. td를 쿼리셀렉트올해서 가져와서 반복문으로 넘겨주고 반복실행내용은 또 그td에 클릭이벤트를 붙인다 라는 코드임!

//65.3> 요밑에 코드는 지금 삭제된상태임!!

// tbody.querySelectorAll('td').forEach(function(td){td.addEventListener('contextmenu',function(e){ //56> 이렇게 클릭이벤트를 달아서 우클릭할시 나타나는 기능을 구현하는 코드를 짠다.
// e.preventDefault(); //62> e를 파라미터로 주고(이벤트실행시(클릭시)) 함수안에서 e.프리벤트디폴트 하면,일단 브라우져의 기본동작을 막는 기능인데 브라우져에서 우클릭시 뜨는 메뉴는 기본제공기능인데 그 디폴트(기본기능)를 차단하는 코드를 넣었다.   
//     console.log('오른쪽 클릭'); // 62> 아무튼 지금 그래서 오른쪽클릭이 되는지 콘솔로 찍어보는거다. 되면 콘솔에메세지가 뜨겠지...//근데 지금 안뜨는데,,ㅎㅎ 이거는 항상 안될때는 크롬개발자도구 드가서 해당 엘리먼트를 선택하고 이벤트리스너 란을 확인하면 이벤트가 달렸는지 아닌지 확인할수 있다.
// // 63> 지금 안뜨는 이유는 결론적으로 지금 td가 없는상태이다. 그러니 td를 불러올수가 없는거다 왜냐면 지금 저위에 클릭이벤트에 포문에서 td를 만들어서 썻을껀데, td를 불러보니 비동기이니까 코드가 다 실행되고 맨나중에실행이된다 그러니까 코드상으로 보면 아직 없는 상태로 뜨는거다.
// // 64> 그래서 이부분을 다시 수정해야된다. 어떻게하냐면 저위에 포문에서 td를 만드는 순간에 바로 컨텍스트메뉴 즉, 이벤트 리스너를 달아주면된다.
//     });
// });

//66> 자 이제 오른쪽 클릭이 로그에 찍힌다. 즉, td는 비동기이므로 , td를 만들자마자 추가해주면 ,그래서 아예 비동기로 다처리되도록 바로 이벤트를달아버려서 처리해서 이제 오른쪽클릭하니까 먹히는거다.
//66.1> 참고로 비동기란 기다리는거다 즉, 대기중이었다가 실행하라고하면 그제서야 실행이되는 코드다. 그러면 비동기는 맨나중에 실행이되겠죠? 
//66.2> 그럼 이벤트리스너는 뭔가?? 해당 이벤트에대해 대기중인 코드이다. 항상 리스닝 중이다. 그래서 듣고있다가 그 이벤트를 어디선가 클릭을하던 뭘하던 호출이되는 순간에 실행이되면 그게 이제 큐라는곳에서 대기하다가 스택으로옮겨져서 실행이되는 방식이다.
//67> 그래서 크롬에서 이벤트 확인하면 이벤트가달린걸 확인할수 있을꺼다.
//68> 그래서 저 위에 td는 지금 포문안에 반복으로 돌리면서, 왼쪽 클릭을 하면 이벤트를 실행하는 이벤트를 달아놓았다.  따로 밑에 안만들어줘도 되고, 만들자마다 이미 포문안에 있으니 그냥 이벤트리스너만 달면 된거다.



// //타겟이랑 커런트타겟 비교 
// tbody.addEventListener('click',function(e){

// console.log('타겟',e.target); //클릭된 대상을 가져옴
// console.log('커런트타겟',e.currentTarget); //클릭된 이벤트리스너를 단 대상을 가르킨다.
// 그래서 이벤트를 단 대상과 실제로 이벤트가 발생하는 태그 를 가르키는 차이점이 있다.
// });

