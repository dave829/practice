// //1그래서 일단 자바스크립단에서는~ 클릭이벤트를 달아주고요,지금 카드를 클릭했을때 바뀌는걸 하는중임!
// //3 그래서 오늘 할꺼는 카드 12개가 있으면, 카드들을 뒤집어서, 서로 같은 모양 카드맞추면(짝 맞추기),그래서 다 같은 모양 맞추면? 이기는?게임을 구현하는거
// document.querySelectorAll('.card').forEach(function(card){
//     card.addEventListener('click',function(){
//         card.classList.toggle('flipped'); // 2스위치같은게 토글임! 지금 카드를 클릭했을때 바뀌는걸 하는중임!
//     });
// });

//4그러나 지금 카드를 색깔로 표현하는게 나을것같아서, 위의 코드는 지우고 다시짜야한다.
/////////////////////////////////여기 위의 코드는 이전코드임///////////////////////////////////////////////////////////////

//////////////////////////////여기서부터 코드시작//////////////////////////////
var 가로 = 4;
var 세로 = 3;
//5 4*3 의 카드들을 만들어서 즉 12개의 카드를 만들어서 , 뒤집으면서 짝을 맞추는 게임을 만드는데,

//33 여기서 카드 색깔을 정해주는거를 세팅해보자.만들어 본다. // 앞면이 지금 남색이기때문에 파란색계열은 피하자..
//34 그리고 두개씩 짝을 맞춰야 되니까 각각 똑같은색을 배열에 더 추가해준다.
var 색깔들=['red','red','orange','orange','green','green','yellow','yellow','white','white','pink','pink']; //106 여기 하나 만들어서 해놓고
var 색깔후보=색깔들.slice();  //107 여기는 요렇게 하면 이제,,백업을 하나 해놓는다고 보면된다. 
//35 그다음에 애네들을 섞어야 겠죠, 왜냐면 안섞으면 애네들이 너무쉽게 두개가 붙어있으니 바로다음께 나오니까 쉽게 보이잖아요, 그래서 섞어야됨
//36그러면 for문을 이용해서 섞어봅시다.

var 색깔 = []; //38 빈배열 생성후

var 클릭플래그=true; //57 여기 플래그 변수를 만들어 , 기본값(디폴트는) true 로 준다. 그래서 클릭플래그가 true일때만 클릭을 허용하게끔 해주면 된다. 그럼 그외의 상황에서는 클릭이 안되게끔 해주면 ,사용자들이 클릭이 안되겠죠. 그럼 밑으로가서 클릭이벤트에다가 if문으로 해주면 되겠죠.

var 클릭한카드=[];//65 일단 여기 변수를 하나만든다, 클릭한카드라는 변수는 클릭을 한 카드가 2개일때 라는 조건을 하고 부합될시 , 비교를 하는 코드를 짜면 된다. 그럼 여기 클릭한카드라는 변수의 빈 배열을 하나만들고 이 배열에들어간 애들을 비교하는식으로하면 되겠죠, 그래서 밑으로가서 클릭이벤트로 가보자. 

var 완성카드=[]; // 91 완성카드가 되면 더이상 클릭을 못하도록 할것이다.그래서 일단 여기에 빈배열 완성카드를 하나 만들어놓고 이제,,

var 시작시간; // 97 이렇게 얼마나걸렸는지 시간 기능을 넣으려면, 여기 일단 만들어두고, 밑에가서~

function 셔플(){ //피셔에이츠 셔플 //111 이렇게 여기는 지금 문제가 랜덤으로 섞는게 안되고있어서,,그 문제를 해결하기 위해 셔플이라는 함수를 따로 만들어줘서 이 함수안에 랜덤카드가 만들어지는 코드(샐깔을 랜덤으로 입혀주는 코드)를 밑에서 이 함수 안으로 옴겨서 놓고 밑에 부분에서 이 함수를 실행시켜서 카드를 섞는작업이 실행 되게끔 하는거다.
    for(var i=0;색깔후보.length>0;i += 1){ 
        색깔=색깔.concat(색깔후보.splice(Math.floor(Math.random() * 색깔후보.length),1)); 
    };
};
/////////////////////각각의 카드별로 색깔을 랜덤으로 입혀주는 코드 시작지점///////////////////////

// for(var i=0;색깔후보.length>0;i += 1){ //37 색깔 섞는 코드 // 섞을때 항상 쓰는 코드는 피셔에이치 방식(랜덤으로섞는 방식)으로 했었죠, 그방식을 하기위해서는.. 일단..후보들의 배열이 있고, 반복문을거쳐 랜덤으로나온 값을 빈배열에 담는 방식이죠,그리고 색깔후보.length>0 이렇게 조건을 주는 이유는 ??모르겠다
//     //색깔.concat(색깔후보.splice(Math.floor(Math.random() * 색깔후보.length),1)); //39 랜덤값 생성(이게 피셔에이치 방식임!)
//     색깔=색깔.concat(색깔후보.splice(Math.floor(Math.random() * 색깔후보.length),1)); //45 그래서 여기까지 하고 밑에 로그를 찍어보면 랜덤의 색깔들이 로그에 찍힌다.이제 이걸 이어주는 매칭해주는 작업을 해야겠죠.. 그면 일단 애네들을 카드 뒷면에 엮어줘야겠죠.그래야 카드 앞면하고 비교를 해야하니까요.그럼 밑으로가서..
//     //console.log(색깔[i]);
//     //44 console.log(색깔후보.splice(Math.floor(Math.random() * 색깔후보.length),1));
// }; //40 그니까 이코드 설명은, 일단 어떻게 되야되냐면, 지금 이 게임은 랜덤하게 카드가 뽑혀서 비교를해서 그 결과를 보는? 게임 이니까...
//41 그래서 그렇게 되려면, 일단 랜덤숫자를 만들어서 그랜덤숫자는 인덱스가 되야되고 그 랜덤한 인덱스에 해당되는 애는 색깔후보라는 배열에서 그인덱스가 예를들어 2가 나왔으면 오렌지니까 오렌지가 뽑혀서 색깔 배열에 추가하여, 따로 저장되는 방식으로 해서 비교가되게 만드는 코드를 짜야겠죠?

//console.log(색깔);//42 로그찍어서 잘 섞이나 확인해본다. 
//43 일단 저 색깔.concat(색깔후보.splice(Math.floor(Math.random() * 색깔후보.length),1)) 이코드 자체는 색깔이라는 새로운 배열을 만들어서 추가가 된상태이다. 그러니 실제 색깔이라는 배열에는 들어가있지 않은 상태이므로 var 해서 넣어줘야된다.

//6 일단 카드 12개를 함수를 이용해서 만들어 볼께요

//17 그래서 지금 우리가 지금해야될께, 가로 곱하기 세로 만큼 카드를 생성 해야 되니까. 이코드를 반복문을 돌리면 되겠죠! 지금 가로4세로3로 해놨으니 12니까 포문돌리면 카드는 12개 생성되겠죠

/////////////////////카드를 세팅하는 함수 시작지점/////////////////////
function 카드세팅(가로,세로){  //7(새로운카드 생성코드!!) 저희가 이제 스코프라는걸 배웠으니까, 매개 변수를 이용해서,매개변수도 변수죠,변수명 같은것도 쓸꺼에요,
    
    클릭플래그 = false;
    
    //cardframe.appendChild(card);
    
    for(var i=0;i<가로*세로;i+=1){//18 이렇게 포문을 만들어놓고 포문실행문 안에 밑에 카드생성코드를 넣으면 된다.
        //19 포문안에 ~ 코드 붙여넣기!

        //8 참고로 여기 도큐먼트크리에이티브하는거는 이미 이렇게 만들어논순간 코드가 이미 인터프린터시점에서 실행이되어 생성이되는거고, 변수에저장도 동시에 되는거임,여튼 다른 코드들도 그렇다.
        var card = document.createElement('div'); //9 이렇게 카드들을 (생성)만들어준다. 밑에도 동일하게,..,
        //10 card.classList.add('card'); //원래는 이런 방식으로 ,,위에 생성된 엘리먼트에다가, 클래스를 추가할때 이런 방식으로 추가를 하는데,(여러개를 추가할시 리스트로도 할수있고)
        card.className = 'card'; //11 근데 클래스를 하나만 추가를 할때는 클래스네임으로 이런 방식으로 해줄수도 있다.(자바스크립트에서는 클래스네임이다.)
        //console.dir(card);
        var cardInner = document.createElement('div');
        cardInner.className = 'card-inner';
        var cardFront = document.createElement('div');
        cardFront.className = 'card-front';
        var cardBack = document.createElement('div');
        cardBack.className = 'card-back'; //12 이렇게 각각의 엘리먼트에다가 클래스를 추가(붙여준다음에)해준다음에,
        //13 중간지점?에서 어펜드로 짝을 맞춰가면된다, 여기서 중간지점?인 아이는 카드이너이다. 카드이너는 카드프런트와 카드백을 가지고 있게 설정하면되므로 어펜드차일드로설정하고, 또 카드는 카드이너를 어펜드차일드하면 딱 계층?이 연결이 된다.
        cardBack.style.backgroundColor=색깔[i]//46 여기 카드뒷면에서 css설정을해준다 백그라운드컬러로 색깔배열을 하나하나씩 넣어주면된다. 그니까 색깔[i]하면 사실 이미 색깔에는 이미 인덱스마다 다 랜덤색깔이 들어가있고 [i]를해주는거는, 하나하나씩 그냥 출력되게하는거다.
        //47 그래서 이렇게 카드 뒷면도 랜덤으로 세팅은 끝 났는데,,,
        //48 그래서 이제 또 뭘하냐면, 처음에는 카드색깔을 다 보여줘야겠죠(오픈),그 다음,3초후 다시 카드가 닫히는걸 구현해보자.그럼 처음에,,카드세팅함수가 완료가 되면, 
        cardInner.appendChild(cardFront); //14 이런식으로 계층구조?로 이어준다
        cardInner.appendChild(cardBack);
        card.appendChild(cardInner); // 15 여기도 이어준다.
        
        //console.log(card,"카드로그"); //70 즉 여기서도 카드를 찍어보면 각각의 카드 , 즉 12개의 div 가 나온다. 즉 카드는 12개의 div로 이루어져있고, 카드를 가져온다는건 12개의 div요소를 다 가져온다는 뜻이다. 
        //console.dir(card+"카드dir");

        //27 요렇게 즉시 실행함수를 만들어준다. 
        //71 여기서 짚고 넘어가야할 정말 중요한 점이 있는데, 여기즉시실행함수에 마라미터 c 는 각각의 개별의 카드를 가르킨다. 즉 두번째 카드를 클릭을하면 두번째 카드가 선택이 된다는거다. 이게 뭔소리냐면 , c는 카드 즉, 12 개 div요소를 다 지칭하는게 아니라. 하나 하나의 스코프를 다 생성해서 각 각의 Div로 스코프를 다 들고있는것이다. 위에서 card라는 변수를 찍어보면 12개의 카드를 다 출력하지만, 여기 즉시 실행함수에서 넘어온 c 는 카드 하나하나 별도로 다 12개의카드가 아닌 각자의 카드의 개별의 스코프를 들고 있다. 즉 어떻게보면,카드를 하나씩 출력이 되게 할수있다는말이된다. 그래서 즉시실행함수가 실행이 된떄는 이미 c.뭐뭐 하면 카드 하나 를 의미하니까 여기다가 클릭 이벤트를 달았으니까 각 각 개별의 카드에 클릭이벤트를 단것과 마찬가지이므로 카드를 하나 하나씩 클릭을 할수가 있게된거다. 그럼 클릭이벤트안에 또 무슨코드를작성하면 이거는 카드 개별로 하나하나에다가 효과를 적용시킨다는 뜻이 된다.
        //72 여튼 여기 왜 즉시실행 함수를 넣는가이다? 그리고 왜 c라는 파라미터를 받는가? 이거는 원래 클로져 문제때문에 카드가 for문을 돌면서 스코프는 가장 마지막껄 들고있어서 마지막 카드(div)만 적용이 되므로 즉시실행함수에 넣어서 for문을 돌리면 for문이 요소하나하나 돌면서 즉시실행함수도 하나하나씩 실행이되니까(파라미터로 받아버리기떄문에 그게 c 이다.) 카드를 각각 선택 할수있게 된 것이다. 즉 12개의 카드가 하나하나의 카드,즉 카드 개별로 별도의 스코프를 들고 있다는것이다.
        (function(c){ //클로져문제해결 //여기서 c 는 즉식실행함수 밑에 괄호에보면 (card)라고 되어있죠, 저 card를 여기서 c 로, 즉 파라미터로 받은거에요 즉,c는 card를 가르키고 card는 위에 card변수를 가르키고 card변수는 html에서 div엘리먼트를 가르키죠 이 div요소는 .card라는 클래스를 가지고있구요 css도 달려있죠.
            
            //근데 여기는 왜 card.이벤트를 달았냐면, c 로 달면 하나씩 이벤트가 다 달리기때매 메모리를 낭비하니까 그럴필요없이 그냥 위에 card변수껄 들고와서 걍 카드전체에 적용시키는거고, 밑에 c. 뭐로 한거는 각각 카드 개별로 별도로 뭘 적용시킬때는 c.뭐로 하면 되는것이다.
            card.addEventListener('click',function(){ //23(비동기) 카드에 클릭이벤트 달아준다. 클릭하면 카드가 앞뒤로 바뀌는 토글을 설정해준다. // 추가로 여기서 클릭하는 이벤트는 즉,12개의 카드 전체를 의미한다. 즉, 카드들을 클릭할때 아래의 코드가 작동이 된다는 의미 입니다. 즉 일단 클릭이벤트는 카드 전체에 달아 논거죠 왜냐면 어떤 카드를 누르건 간에 다 클릭이벤트는 적용이 되야 하니까요.
                
                                                        //60 그니까 플래스를 정리하자면, 그냥 쉽게, 플래스라는 변수를 하나 만들어서 (기본값은 트루로 주고), 그냥 사용하고싶은곳에 if문을 두고 false로 주었다가 밑에서 끝나는 셋타임아웃에다가는 다시 true로 주면 if문 조건이 true로 바뀌니까 다시 동작을 한다는것임. (물런 클릭이벤트에서,,,)
                                                        //59 그니까 이 클릭플레그가 false니까 이의미는 아예 지금 클릭이벤트가 안먹히는거다. , 사실 안먹히는건 아니고, 클릭이벤트는 자동실행함수안에 있어서 실행은되지만 if문의 조건에 맞지 않으므로 실행이 안되고 있을뿐이다. 그럼 이제 카드세팅이 완료되고나서 다시 이 클릭이벤트가 작동되게 만들려면, 아래로가서 true값을 다시주면된다.
                                                        if(클릭플래그 && !완성카드.includes(c)){//58 여기다가 if문을 만들어준다. 지금 여기 클릭플래그의 값은 false이다 왜? 그래서 위로가서 카드세팅시에는 클릭이 안되게 해야되니까 클릭플래그를 false로 줘야한다. 그래서 지금 값이 false인것이다. 왜 false를 주냐면 클릭이 안되게 해야되니까.그래서 위에서 false니까 여기서는 위의 값을 가지고오니까 false인것이고,,이제 밑으로가서 카드세팅이 완료되면 클릭이 가능하게 true로 줘야된다.
                                                                        //94 지금 위에 코드를 보면, !완성카드.인크루즈 c 이렇게 되어있는데 일단 인클루즈는 최신자바스크립트고 뒤에 c는 클로져문제때매 c로 쓴거고 c는 card를 의미한다. 그리고 앞에 !느낌표는 무슨말이냐면, 완성카드가 아닐때만 클릭을 할수있다 는 뜻이다 ,즉 완성카드를 제외하고, 완성카드만 제외하고 다른카드들을 누를수있다는 것! 일단 여기까지해서 기본은 완성이 됬고, 추가로 이제,,

                                                                        //73 그래서 사실 이 토글이것도 앞에 c. 이렇게 붙어있는 이유가 뭐냐면 카드를 클릭할떄 그 클릭한 이벤트 자체는 그냥 이벤트이고 ,즉 카드자체는 12개의카드 전체에 한방에 이벤트는 달려있지만, 그건 이벤트가 되는 걸리는 시작점?이라 별개이고, 이 c. 이거는 카드를 그니까 카드가 12개 있으면 내가 누른 카드가 직접 선택이 되는거다. 하나하나에 
                                                                        c.classList.toggle('flipped'); // 24_1 card클래스에 토글을 달아서 flipped 이라는 클래스를 추가하면서 동시에 토글기능도적용되는거다, 즉 다중 클래스인데, card와 flipped 클래스가 같이 생겼다가 flipped만 없어졌다 하는거다. // 토글기능은 없으면 만들고 있으면 삭제시키는기능이다.즉 flipped클래스가 없으면 추가시키고, 있으면 없애는 기능을 한다.
                                                                        //console.log(c,"이카드야"); //74_1 이렇게 로그를 찍어보면 c를 찍어보면 카드를 클릭하면 그 클릭한 카드가 딱 찍혀서 로그에 뜬다 1번째 카드를 클릭하면 1번쨰 카드가 로그에찍혀서나온다 물런 나1번째카드다 라고 로그에 뜨지는않고 그냥 div이렇게 나오긴하는데(그건 인덱스를 달아주면되나?)여튼 중요한건 개별의 카드를 클릭하면 그 클릭한 카드를 가르킨다는 점이 중요하다 .!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 즉 c. 하면 그 클릭한 카드를 가르킨다라는 의미이다.
                                                                        var 씨 = c;
                                                                        //console.log(씨,"씨"); //74_2 그니까 클릭을하면 자동으로 그 클릭한 엘리먼트를 가르킨다.
                                                                        //24_2 그래서 이 조건(card flipped) 이렇게 둘다 있을때 css 효과 를 적용 시키고, 두중 하나라도 빠지면, 적용이 안되게 하는 기능을 쓰는것임. 플립드란클래스가 없으면 추가하고, 있으면 빼고 하는거다.

                                                                        //66 여기 if조건문 안에서 구현을 한다.
                                                                        //69 일단 지금 중요한게 생각해봐야되는게 뭐냐면, 카드라는건 지금,,애초에 어떻게 만들어졌냐면, 일단 하나의 div가 생성이 되서, 거기에 css를 입혔어요, 그럼 하나의 박스를가진 틀을가진 애가 div가 화면에 출력이 된거죠, 근데 개를 자바스크립트에서 불러와서 for문에 넣어서 돌려요 어떻게? 4*3으로 해서 돌리니까 1개였던 카드가 12개가 되요, 그래서 카드는 12개로 늘어난거죠 어떻게? for문의 결과로인해서요, 근데 생성할당시에 클래스를 달아주었죠, 클래스는 하나의 이름표에요 그 이름표를 단애가 for문을 통해 12개로 늘어난거죠, 즉 card란 (클래스를 가진애는) div이고,즉 12개의 div 인거죠 즉, 또한 카드라는 클래스는 12개전체를 의미합니다. 클래스는 왜 필요하냐면 자스에서나 css서 불러서 뭘 만들때 사용하는 이름표입니다. 물런 div로 불러도되는데 보통은 클래스를 달아줘서 그 클래스이름표로 불러와서 뭘하죠, 여튼 카드라는 클래스를 부르던 div를 부르던 가지고오는애는 12개의 div라는 사실입니다. 여기서 잠깐 짚고넘어가자면 클래스는 css가 아닙니다. 클래스는 html쪽이에요.id도 html쪽이죠, css는 단지 그 선택자를 불러올때 사용하는 것 일뿐입니다.
                                                                        //75 그래서 여기 클릭한카드.push(c) 이거 에서 c 를 넣으면 클릭한카드 빈배열에 내가 클릭한 한카드를 푸쉬,즉 넣겠다라는 의미다 즉, 내가 만약 첫번쨰카드를 누르면 바로 클릭한카드 배열에 들어가는거다.
                                                                        클릭한카드.push(c);//67 일단 클릭한카드변수의 빈배열에다가 푸쉬 즉,넣는다.뭘? c 여기서 c는 위에보면 파라메터죠 즉 클릭할때 넘어오는 하나의카드를 의미합니다. 즉 카드들을 빈배열에 넣는다 라는 코드입니다. 즉 클릭할때마다 그 클릭한 카드는 배열로 저장이됩니다. 그래서 빈배열에 카드를 넣고
                                                                        if(클릭한카드.length===2){ //68 이 조건이 만족할시 밑의 코드를 실행시킨다. 즉 여기서 조건은 클릭한카드들 즉 카드들.lenght니까 카드들의 숫자를 의미합니다. 즉, 카드들의 숫자가 === 2 즉, 두개일때 , 밑의 코드를 실행한다. 입니다.
                                                                            //76 그래서 여기서 해야하는건 클릭한 카드 2개의 색깔이 같냐 틀리냐를 해줘야겠죠.   
                                                                            //77 지금 이거는 뭐냐면, 일단 클릭한카드[0],클릭한카드[1] 은 뭐냐면, 일단 클릭을하면 저기위에 클릭한카드 빈배열안에 클릭한카드[0] 클릭한카드[1] 이렇게 쭉쭉 들어갈꺼 아니에요, 근데 위에 조건문에 2라고 되있으니  빈배열안에 2개가 들어오면 넘어가는거다. 
                                                                            
                                                                            //console.log(클릭한카드[0].querySelector('.card-back').style.backgroundColor);  //80 혹시나 안 찾아질수도 있으니까 콘솔로그로 찍어본다. 결과는,,잘 찍힌다.
                                                                            //console.log(클릭한카드[1].querySelector('.card-back').style.backgroundColor); //81 same here
                                                                            //클릭한카드[0].querySelector('.card-back').style.backgroundColor; //78 그리고나서 이 클릭한카드[0] 에서 .querySelector를 한이유는 이 클릭한카드[0]에서 .card-back 클래스를 찾는다 라는 거고, 찾으면 그요소에다가 스타일을 붙인거다. 
                                                                            //클릭한카드[1].querySelector('.card-back').style.backgroundColor; //79 여기도 마찬가지
                                                                            if(클릭한카드[0].querySelector('.card-back').style.backgroundColor === 클릭한카드[1].querySelector('.card-back').style.backgroundColor){ //82 그래서 if문 만들고 이제 "두 카드의 색깔이 같다면"이라는 조건 설정후에 넘어가도록 해주면 되겠죠.
                                                                                //84 그래서 여기는 카드색이 같을때는 카드가 그대로 뒤집힌상태 그대로 고정되게 하고
                                                                                완성카드.push(클릭한카드[0]); //92 그래서 여기에 이렇게 클릭카드를 완성카드에 푸쉬해주면 
                                                                                완성카드.push(클릭한카드[1]); //93 그러면...완성카드에 클릭한 카드의 인덱스 0 , 1 이 들어가고 그 해당 카드는 이제 플래그로 거르게되면 클릭이 안되는거다. 그러면 플래그 설정하는 if문으로 가보자~
                                                                                클릭한카드=[]; //89 여기도 할일끝나면 초기화 해줘야되니까. //90 그리고 완성된 카드를 클릭하면 뒤집히는데 그걸 방지하는 코드를 넣어야된다.
                                                                                //95 여기밑에는 추가적으로 메세지를 넣는다.
                                                                                if(완성카드.length === 12){ // 95.1 이렇게 완성카드.랭쓰 하면 완성된카드가 12개일때
                                                                                    var 끝시간 = new Date();// 99 여기도 뉴데이트해서 시간 넣어주고 밑에서는 빼기해서 계산하면 총 걸린시간 나오니까...
                                                                                    // (시작시간 - 끝시간) / 1000; //100 이러면 몇초 걸렸는지 계산이 됨 이걸 알러트메세지에 넣으면 표시가 되겠져
                                                                                    alert('축하합니다! 성공! '+(끝시간 - 시작시간) / 1000 +'초 걸렸습니다!'); // 101 여기 시간계산은 지금 시작시간이 밑에서 찍히고 끝시간이 위에서 찍히니까 끝시간 뺴기 시작시간을 해줘야 계산이 바로 나온다, 여기서 쏙 넣으면 끝 , 그리고 게임이 끝 났으면 항상 초기화를 해주는게 좋다. 그래서 초기화 코드는 ~ 초기화를 하는 방법은 여러가지가 있는데 보통 카드함수 즉 우리가만들어놓은 함수를 재사용하는게 좋다. 카드세팅 함수를 재사용! 지금 카드세팅함수가 하는일이 카드태그까지 아예 새로 만들어주기때문에, 태그는 지우도롭 해봅시다 그럼 우선 html로가서 ...
                                                                                    document.querySelector('#wrapper').innerHTML=''; //104 이렇게 하면 말그대로 이너html에서 내용이 비어 있으니 내부 태그가 다 지워지는거죠  즉, 초기화가 되는거죠..참고로 쿼리셀렉터는 한개의 태그만 선택할때 씁니다.
                                                                                    색깔후보=색깔들.slice();//108 이렇게 초기화해줘야됨 즉, 처음 색깔 상태를 처음상태로 돌려놓는거임!
                                                                                    색깔 = []; // 이부분을 뺴먹으면 게임이 끝나고 색깔이 안섞인다. 왜냐면 끝나고 초기화를 안해주니까 이전 기록 그대로가는거임.
                                                                                    완성카드=[];//109 완성카드도 비워줘야죠. 초기화!
                                                                                    시작시간 = null; //110 시작시간도 처음으로 돌려주고
                                                                                    셔플(); // 112 여기서 카드섞는거 실행!하고 왜냐면 , 여기는 지금 초기화 지점이다 그래서 다 게임이 한판 끝나고 지금 카드색깔을 랜덤으로 섞는거니까 여기 넣어주는거고
                                                                                    카드세팅(가로,세로); //105 이렇게 이어서 카드세팅을 해주면 다시 카드세팅이 처음처럼 되는거죠.
                                                                                } // 96 이렇게 메시지 넣는것. 근데 좀 밑밑하니까 추가로...몇초 걸렸는지도 한번 추가해보면 !
                                                                            }else{ //83 두카드의 색깔이 다를때 아래 실행
                                                                                //85 여기는 카드색이 서로 다르면 그냥 다시 뒤집히게 한다. 그리고 추가로 셋타임아웃으로 1초뒤에 뒤집히게 만들어준다. !!그러나 조심해야되는건 비동기를 항상 할때는 실행순서를 항상 신경써야한다 뭔말이냐면, 밑에보면 초기화 즉 클릭한카드=[] 이렇게 해준부분이 있는데,,즉 클릭한카드=[]이부분이 먼저 실행되고나서 이 동기화(셋타임아웃)가 실행되기때문에 이부분을 처리를 해줘야된다. 안그러면 클릭한카드=[]빈배열이 되버리니까 동기화부분은 아무것도 찾을수없으므로 에러가난다. 해결방법은, 
                                                                                //85_1 이제 해결방법은 셋타임함수 밑으로 넣어주면 된다. 추가로 성격급한사람들은 빨리 클릭을 하기때문에 그걸 막기위해서는 이제, 클릭플래그를 추가로 설정해주면된다. 
                                                                                클릭플래그 = false; //87클릭 방지 코드 
                                                                                setTimeout(function(){ 
                                                                                    클릭한카드[0].classList.remove('flipped'); //86 이거는 이제, 클릭한카드0인덱스에서 flipped라는 클래스를 제거한다라는건데 클래스리스트를 쓴이유는 제거할떄는 리무브를 쓰면 좋으니까 클래스리스트로한거같다.
                                                                                    클릭한카드[1].classList.remove('flipped'); 
                                                                                    클릭한카드=[];//84 여기에는 왜 빈배열을 다시 설정하냐면, 왜냐면 이렇게 초기화를 해줘야 또 여기 배열에 0인덱스랑 1인덱스끼리 비교를하죠. 추가로 이부분은 비동기때매 비동기 밖에 넣어주면 에러가 나므로 비동기 안에 넣어준다. 그리고 여기서 초기화하니까 당연히 위에 카드가 같은경우에서도 초기화를 시켜줘야겠죠 그래야 카드를 선택을 다시하죠.
                                                                                    클릭플래그 = true; //88 클릭방지코드 풀어줌.. 이건 맨 나중에 넣어주는게 좋은 왜냐면 막 클릭할수있기때문에, 배열이 초기화되고나서 풀어줘야 클릭한카드배열에 다른 배열이 안들어가서 꼬이는일이 없게만들기때문.
                                                                                },1000); 
                                                                            } //89 근데 이 구조의 문제점이 있는데, 문제는 같은색갈의 카드를 뽑아놓으면 그카드를 클릭하면 또 뒤집을수가 있기때문에, 완성된카드는 뒤집히지않게 만들어줘야한다. 그래서 위에가서 완성된카드라는 변수를 만들고 그안에 빈배열만들어서 그배열에 들어가있는애들은 터치를 못하도록 만들어주면 되겠죠.
                                                                        }; 
                                                        };//////클릭플래그 조건문 끝부분//////
            }); // 28 이 클릭이벤트함수 부분을 복사해와서 붙여 넣어준다. ///////클릭이벤트 끝부분//////
        })(card); ////////즉시실행함수 끝부분//////////
        //29_1 즉시실행 함수를 설명 하자면, 즉시실행 함수 매개변수에 card를 넣어주고, 또 함수내부의 파라미터로 c를 넣어주면
        //29_2 즉, card는 c로 복사가되고, (즉 같은 값이 전달이되고)
        //29_3 그리고 함수 내부의스코프가 만들어지면서 (즉,c의 스코프가 생성이되고), c는 밑에 c로 전달이 되면서 (즉,card의 값이 전달 전달 되는거임) 이렇게 작동이 된다,즉 클로져 문제는 이렇게 해결이 된다. 

        //25 여기서 이벤트를 달면 스코프문제가 생긴다. 무슨말이냐면, 지금 for문 안에 비동기가 들어있는 상태이라서 클로져문제가 생기는거다. 저번에 했던 그런문제인데 ...
        //26 해결책은 몇가지 있는데, 일단 첫번째는 즉시 실행함수를 이용하는 방법이다.
        //card.addEventListener('click',function(){ //23(비동기) 카드에 클릭이벤트 달아준다. 클릭하면 카드가 앞뒤로 바뀌는 토글을 설정해준다.
        //    card.classList.toggle('flipped'); // 24_1 card클래스에 토글을 달아서 flipped 이라는 클래스를 추가하면서 동시에 토글기능도적용되는거다, 즉 다중 클래스인데, card와 flipped 클래스가 같이 생겼다가 flipped만 없어졌다 하는거다. // 토글기능은 없으면 만들고 있으면 삭제시키는기능이다.즉 flipped클래스가 없으면 추가시키고, 있으면 없애는 기능을 한다.
            //24_2 그래서 이 조건(card flipped) 이렇게 둘다 있을때 css 효과 를 적용 시키고, 두중 하나라도 빠지면, 적용이 안되게 하는 기능을 쓰는것임. 플립드란클래스가 없으면 추가하고, 있으면 빼고 하는거다.
        //});
        //103 여기 밑을 수정을 해줍니다 바디 부분을 쿼리셀렉터로 지정해준다음 어펜드차일드로 카드 넣으면 저 래퍼 태그에 카드가 들어가는거죠 그리고 카드 초기화를 할때도 비워줘야되니까~ 
        document.querySelector('#wrapper').appendChild(card); // 16 이렇게 완벽한? 계층구조?로 이어주면 끝! 이렇게 되면 지금, 카드 하나가 추가가(새로운 카드하나가 생성이) 되는거다.
    }
    document.querySelectorAll('.card').forEach(function(card,index){ //49(참고로 포이치는 인덱스를받을수있다.) 여기서 이제 그 설정을 해줄텐데,, 이렇게 카드를 다 오픈해주는 코드이다. 그래서 쿼리셀렉터올로 카드랑하위애들을 다 불러서 개네들을 다 선택해주고 , 근데 일단 포이치는 카드를 각각 하나하나 따로따로 적용시키는거다. 반복문이니까 인덱스별로 다룬다. 그래서 여기에 셋타임아웃을 적용시키면 카드각각 시간별로 적용이되어 순서대로 쫘라락 펼쳐지는 효과가 나오는거다.즉 포이치는 괄호안에 파라미터를 받는데 왼쪽은 그 데이터(즉해당엘리먼트)를 받고, 왼쪽은 해당엘리먼트들의 각각의 인덱스를 가져온다.즉 포이치는 이미 각각의 데이터를 가지고 반영을 하면서 반복을 하는거다. 그래서 밑에서 그엘리먼트와 인덱스를 갖다 쓸수있는건데. 그럼 밑에보면 이미 각각의 엘리먼트에 셋타임아웃을 적용시키는 조건이 됬고, 타이머를 잘 적용시켜서 하면 그냥 바로 이미 각가의 카드에(엘리먼트에) 타이머를 적용시킬뿐이다.그래서 카드가 카드별로 시간에맞춰 쫘라락열리는거다.
        setTimeout(function(){
            card.classList.add('flipped'); //50 그래서 애네들에다가 flipped클래스를 추가해준다. 추가해주면 css가 적용이 되는데, css에 가보면 flipped 가 추가되면 트랜스폼에 로테이트180이 걸린다, 즉 카드가180도 뒤집힌 상태가된다 즉,카드뒷면이 다 오픈된상태가 되는거다. 그럼 이제 이 설정은 했으니까 여기다가 몇초동안만 오픈하자라는 설정만 해주면되겠죠.
        },1000+100*index); //51 12개의 카드가, 1초부터, 2.2초까지 쫘르륵 열리는효과...참고로 여기부분(타이머는)은 저게 보면 1000+100*index 이렇게되있는게 뭐냐면 일단 연산자우선순위떄문에 곱하기먼저 계산하고 더한다 그러면 index(0부터12까지있음)가 0이면 0곱하기 100하면 0이고 더하기 1000하면 1000이니까 1초고, 인덱스가 12 면 2200 즉 2.2초가 되는거다 즉, 타이머부분은 계산을해서 숫자에따라 반영을 할뿐이다. 근데 왜 중간에 100은 왜 껴있냐면, 뭐 특별한 이유는없고, 1000 * index하면 0이 나와서 아예 값이 없으니까 연산상 100을넣어서 1초부터 2.2초까지 나오게 하기위해서 넣어둔거다.즉 계산상 넣다보니 100이 들어간거다.그래야 맞아 떨어지니까!!
    });//52 즉, 이런 효과도 이제 css를 조작해서 줄수가 있다. 사실 이렇게 시간차를 두고 나타나는 효과는 자주쓰인다.

    //53 위의 효과를 낸다음은(처음에 다 카드를 오픈했으면 (외울시간을주면)) 또 이렇게, 셋타임아웃을 한번더 하여 보여줬던 카드를 5초뒤 다시 닫아준다.
    setTimeout(function(){ //카드 감추기
        document.querySelectorAll('.card').forEach(function(card){ 
            card.classList.remove('flipped');
        });
        클릭플래그 = true; //61 그래서 여기 투르 로 주면 됨...// 즉 false인 동안에는 클릭이 일어나지 않다가, 여기 셋타임아웃이 실행되면서 true가되니까 클릭이되는것임. 
        //62 그래서 여기까지는 성질급한사람들 클릭 방지를 구현했고,
        //63 이제는 클릭해서 각각의 카드를 오픈할시 각각의 카드색깔이 같으면 열린상태로 가만히 있고, 오픈한 카드 색깔이 일치하지 않으면 다시 원상태로(다시 뒤집혀서돌아가는)돌아가는걸 구현을 하면 된다.
        //64 그래서 카드를 두개를 눌러서 비교를 해야되니까 두개가 오픈이 되었을때(두개를 클릭했을떄) 비교가 되게끔 하는걸 해야한다. 그래서 위로가서 만들어보자, 
        
        시작시간 = new Date(); //98 여기 시작시간 넣어줘서 이제,,여기가 카드세팅이 끝나는지점이거든요 그래서 여기 세팅끝나고 딱 시작시간이 실행이 되는 지점이니 여기 넣어줍니다 그리고 여기 var을 안붙이는 이유는 호출스택과 스코프 떄문이란거 아시죠? 

    },5000); 
    //55 자 여기까지는 카드를 보여주고 닫고까지의 효과는 완성인데, 근데 성격 급한 사람들이 카드가 세팅이 되지도 않았는데 미리 클릭을 하는 경우가 있다. 그걸 방지하는것도 구현 해야된다.
    //56 그런걸 방지하는 방법은 플래그 변수라고 하는데 , 플래그 변수를 만들어야된다. 플래그는 보통 if문으로해서 사용한다. 플래그 변수는 위로가서 만들어준다. 

    //54 근데 위처럼 한꺼번에 카드를 다 닫는 효과를 줄수도 있지만, 또 이렇게 스르륵 닫히는 효과도 이런코드로 줄수있다(이 코드는 그냥 위위에 코드를 배껴서 remove만 바꿔준거다 ㅋㅋ) 
    // document.querySelectorAll('.card').forEach(function(card,index){ 
    //     setTimeout(function(){
    //         card.classList.remove('flipped'); 
    //     },5000+100*index); 
    // });

}/////////////////카드세팅함수 종료지점!////////////////////
//////////////////////////카드세팅함수 종료지점!/////////////////////////

//20 붙여넣고 이제, 함수를 선언했으니 실행(호출)해야죠. 
//21 그리고 html에 가서 원래 (테스트로 사용했던) 먼저 생성해줬던 div태그들을 삭제해준다 왜냐면 위에서 자바스크립트로 생성했기때문에 html꺼는 필요가 없다.
셔플();//113 여기서도 실행! 여기는 이제 맨 처음지점 일껄? 그래서 처음 랜덤으로 카드 색깔 뿌려주는 역할을 지금 하니까 넣어주는거고
카드세팅(가로,세로);
//22 그래서 크롬으로 렌더링해보면, 카드들이 12개가 생성이되어있고 div태그로 이루어져있고, 카드들은 일렬로 밑으로 쭈르륵 이어져있는데, 이걸 일렬로 이렇게 정렬된걸 바꾸려면 css로 바꾸면된다,css로가보자.

//30 여기까지 카드기본 세팅(클릭하면 카드돌아가는것까지)했고, 이 다음부터는 카드 색깔을 넣어서 비교를 하는 기능을 구현 해야된다. 예를들어 노란색 노란색나오면 가만히있고, 빨간색,초록색나오면 다시 뒤집히고 이런걸 구현해야한다.
//31 그래서 이제 데이터를 다룰껀데, 각자 카드마다 다른 색깔을 줄꺼거든요, 각자 다 다른 색깔을 주는 부분을 구현해보자.
//32 일단 css가서 카드뒷면 회색으로 색깔준거 지우고~




/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
// 자바스크립트
// .slice(); 설명

// -참조 issue- 설명

// 예)

// var 값 = '제로초';
// var 복사 = 값; //여기선 변수이름을 대입하니까 결과는 원래주소의 값이 나온다.
// 복사
// >제로초

// 복사 = '무지'; //여기선 근데 스트링값을 넣어버리니까 결과는 스트링이 나온다.
// 복사
// >무지

// 값
// >제로초

// 그러나

// 객체/배열/함수 이3개를 통틀어서 객체라고 부르는데,,,
// 여튼
// 이 3개
// 객체 / 배열 / 함수 는 
// 대입하면 
// 즉, 주소값을 대입하면 그 주소값이 그대로 남기때문에 연결이 계속된다. 이걸 참조라고 한다.

// 예)

// var 사람 = {
// 	이름 : '제로초'
// }

// var 복제인간 = 사람; // 여기에 객체를 넣어버리면 이 객체의 주소값을 가리키게 된다. 즉 연결된 상태

// 복제인가.이름 = '무지';

// 복제인간
// >{이름:"무지"} // 이미 여기서 바꿧기때매 

// 사람
// >{이름:"무지"} // 여기도 원래값 바뀐 값이 나오는거다

// --------
// 예)

// var 배열 = ['사과',''오렌지,'포도'];

// var 복사 = 배열;

// 복사
// > ['사과',''오렌지,'포도']

// 복사[0] = '귤';

// 배열
// >['귤',''오렌지,'포도'] // 위에서 바꿧기때매 주소값 때매 연결되있으니까 바뀌는거다.

// ----------
// 예)

// var 함수 = function(){}

// 함수.abc = 'abc';

// var 복사 = 함수;

// 복사.abc
// >abc

// 복사.abc = 'def'

// 함수.abc
// >def
// ----------------
// 정리하자면
// 복사를 변경했는데 함수도 변경이 되는 이런 걸
// 참조떄문이다 
// 즉, 주소값으로 연결이 되서 (객체는 주소값을 넘겨주므로)
// 원래 애가 바뀌는거고,

// 일반 값(문자열 , 숫자, 불린 )
// 이렇게 원시값을 가진애들은 주소값을 넘겨주는게 아니라 그냥 애들이가진 이름주소를(변수명) 넘겨주므로 즉, 밑에깨 바뀐다고 위에꺠 바뀌지 않는다는 말이다.

// 결론:
// 원시값들은 바로 복사할때 참조의형태가(참조자체가 안됨) 아니라 바로 복사가 되는거고,
// 객체형태들은 참조(원래 주소값 을 가리킴)가 일어난다.
 
// ----------------
//  그럼 객체를 복사를 하고싶으면 어떻게 해야되냐면?
// 일단 
// 여러 방법중
// 무식한 1 by 1 으로
// 하나씩 복사하는 방법이 있는데,

// var obj = {a:1,b:2};
// var obj2 ={};

// obj2.a = obj.a;
// obj2.b = obj.b;

// obj2
// >{a:1,b:2}

// obj2.a = 3

// obj.a
// >1 //즉 변경되지않았다.

// 이렇게 하나하나씩 복사하는방법,
// 왜냐면
// 즉, a도 원시값 b도 원시값 형태기때매 복사가 가능하다.

// 그다음 방법은

// var obj = {a:1,b:2,c:3};

// Object.keys(obj) // 이거는 내장된 함수인데, 이렇게 적고 저 괄호안에 객체이름을 넣으면 그냥 저 객체안의 내용물이 선택되서 출력이 된다.
// >["a","b","c"] //이렇게 배열형태로 출력이된다.
// 이걸 이용해서

// var obj2 = {}; //빈객체하나 만들어놓고

// Object.keys(obj).forEach(function(key){
// 	obj2[key] = obj[key];
// });
// //이렇게 하면 이게 뭐냐면 포이치로 돌리는데 key라는건 뭐냐면 ["a","b","c"] 이걸 받아오는거다.
// 즉, obj의 내용물을 받아서 루프를 돌리는거지 ..
// 그래서 그안에 실행은 obj2[key] = obj[key];요기 이렇게 대입 시켜줘라 하면 복사가 되는거다.

// 그럼 결과는,,,
// obj2
// > {a:1,b:2,c:3}

// obj.a = 4; 바꿔봐도

// obj.a 
// >1 //바뀌지않고 그대로 값을 가지고있으므로 복사는 잘 된것이다.
// 즉, 서로 참조형태로 연결된게 없음!!걍 값만 복사된거임 , 참조 관계가 아닌거임.

// ---------------

// 만약 객체 끼리 참조 관계가 있는지를 알아보고싶으면 ?

// === 요거 쓰면 된다

// 즉,

// var obj = {a:1,b:2,c:3};

// var obj2 = obj;

// obj === obj2
// >true
// //이렇게 트루가 나오면 서로 참조관계인 것이다.
// 애네둘은 연결 되어 있다.는거죠

// ----
// 참고로>>>>>
// 이게 객체는 이해를 잘 해야되는게 뭐냐면
// 변수도 그렇지만
// 일단은
// 값을 대입하기 전에는 가리키는건 주소이다.
// 다만 원시변수는 그 주소가 끊어지고 덮어쓰기때매 그렇게 되는거고

// 객체 안의 변수는 
// 일단은 그 주소값을 가리키고는 있지만,
// 만약 그 변수에 값을 덮어쓰기 하면
// 그때 값이 덮어쓰기가 되는거고, 그 전에는 원래의 주소를 가리키고 있는 상태인것이다.

// 이게 그 프로토타입 상속받을때, 이렇게 되는건데,
// 자기만의 값을 가지는 타이밍은 값이 주어질때 이다. 그때 가리키던게 끊어지는거지 뭐,,이미 자기만의 고유의 방이 만들어져있는게 아니라는 소리다.

// 즉,
// 예를들어
// obj2.b.c 를 찍으면 1 이 나온다치면
// 이건 obj.b.c를 아직은 가리키고 있기때문에 들고있는거고
// obj2.b.c = 8; 을 넣으면 이걸 하는순간 똭! 자기 방이 만들어지면서 8이 찍히는거다.
// 물런 obj 랑 obj2 랑은 값이 틀려지지

// 이 설명들은 프로토타입 상속때를 말하는거임.
// ------

// 아무튼

// 이어서 가자면

// 또 다른 문제가 생길수 있는데

// 만약
// 객체 안의 객체는 복사가 되냐 참조가 되냐 이다.?
// 정답부터말하면 겉에꺼는 복사가되고 안에객체는 참조가 된다

// 왜냐면 포이치 루프를 쓰면 당연히 대입의 관계가 되어 === 이런게 옴겨지는 거니까
// 즉, 원시값들은 복사가 되고 객체를 === 이렇게 하니까 참조로 되는거다.
// 루프는 아무잘못이 없다 ㅋㅋㅋ
// 그냔ㅇ 시키는대로 했을뿐,,,
// 아무튼 그렇다
// 즉,
// 예를들어

// var obj = {a:1 , b:{c:1}}  //이렇게 a는 지금 원시값을 가지고있고, b는 객체를 가지고있으니까,,이게 대입되버리면 참조가 될수밖에,,,

// var obj2 = {};

// Object.keys(obj).forEach(function(key){
// 	obj2[key] = obj[key]; // 자 바로 여기서 = 이거 는 을 했으니 걍 원시값은 복사되고 객체는 참조로 되는거다...
// })

// obj2
// >{a:1,b:{...}}

// obj2.a = 5;

// obj.a
// >1 //이건 안 바뀐다 왜냐면 지금 객체끼리는 참조된게 아니다, 연결된게 없고 값만 복사해왔으니까 원시값은 그대로니까

// 그러나

// obj2.b.c =  8;

// obj.b.c
// >8 // 어엇...원래 1이였는데 8로 바꼈다..즉 안의 객체는 참조가 되어 서로 연결이 되었으니 바뀌는거다.

// -----------

// 이해를 돕기위해 
// 포이치 반복문을 그냥 
// 일반 문으로 풀어서 표현해 보자면,,,
// 즉 
// 굳이 포이치를 안 쓰더라도 , 걍 무식하게 복사해보자면,,,

// var obj = {a:1 , b: {c:1}};
// var obj2 = {};

// obj2.a = obj.a; //즉 여기는 원시값만 복사가 되는데,,,
// obj2.b = obj.b; 여기는 = 이거 는 을 해버리면 복사가되는것이 곧 객체를 참조하는게 되는거니까...참조가 되는거죠.
// 이렇게 되는거다.

// -----

// 이런 경우는 해결책은 
// 재귀함수를 써야된다.

// 일단 설명을 쉽게 하자면...

// Object.keys(obj).forEach(function(key){
// 	// obj2[key] 가 객체면 이작업을 한번 더 해주고
// 	// 객체가 아니면 즉, else obj2[key] 가 원시값이면 
// 	obj2[key] = obj[key]; // 한다
// })

// 이 거를 코드로 , 재귀함수로 풀면 

// function copyObj(obj){
// 	var copy = {};
// 	if (typeof obj === 'object' && obj !== null){
// 		for(var attr in obj){
// 			if(obj.hasOwnProperty(attr)){
// 				copy[attr] = copyObj(obj[attr]);
// 			}
// 		}
// 	}else {
// 		copy = obj;
// 	}
// 	return copy;
// }

// obj2 = copyObj(obj)

// obj2.b.c = 8;

// obj.b.c
// >1

// 근데 이 함수도 불안전하다 
// -----------

// 다른 방법은...

// obj = {a:1 , b:{c:1}}

// obj2 = JSON.parse(JSON.stringify(obj)); // 이 함수인데 ...저 괄호 안에 복사하고싶은 객체를 넣으면 된다

// 이렇게 하면 복사가된다. 물런 내부 파라미터의 객체 까지 다 복사가 되고 참조는 되지 않는다.

// 이 방법이 훨씬 간단하다.
// 이 방식을 쓰면 된다.

// 근데 이것도 완전한 복사 함수는 아니다.
// but 이게 그나마 가장 낫다.

// -------------

// 그리고 또다른 방법은

// .slice();
// 이거 인데

// arr = [1,2,3];

// arr2 = arr.slice();

// arr2[0] = 10;

// arr[0]
// >1 // 즉 안바꼈다.

// 이 방법도 있다.
// 근데
// 슬라이스는 단점이 있는데,

// 정확히는 복사하는 방법은 아닌데,
// 복사는 되는?

// 즉,
// 이건 뭐랑 같냐면
// 처음에
// var obj2 = {};

// Object.keys(obj).forEach(function(key){
// 	obj2[key] = obj[key];
// 이거 랑 같다.

// 불안전한 복사 방법...


// ---------------

// 요약 >>>>>

// var a  = 100 
// b = a // 이거는 복사다 왜냐면 원시값이니까

// var c = {a:1}
// var e = c; //이거는 참조다 왜? 객체니까

// var f = {}
// Object.keys(c).forEach(function(key){
// 	d[key] = obj[key];
// }); // 1단계만 복사되고 , 뒤에껀 (뒤에 객체가있으면) 참조가 되버림 불안전한 복사임..

// var arr = [1,2,3]
// var arr2 = arr1.slice() // 애도 1단계만 복사되고 , 뒤에 객체가있으면, 나머지는 참조가 되어버림 즉, 불안전한 복사


// 참고로, 1단계란 그냥 객체안에 원시값만 존재할떄, 
// 2단계는 객체안에 객체가 존재할떄, 배열안에 배열이 존재할떄,,,,


// 유일하게 그나마 완전하게? 복사가 다 되는 방법은

// var obj3 = JSON.parse(JSON.stringify(obj1)); // 완전히 복사 즉, 1단계 2단계 다 복사만 됨 성능 최악
// var arr3 = JSON.parse(JSON.stringify(arr1)); // 완전히 복사 즉, 1단계 2단계 다 복사만 됨 성능 최악

// 정리하자면

// 위에 재네 둘은 1단계 일때만 쓰는거고 (이것만 써도 충분하다...)
// 그러나
// 막 2단계 즉 객체안에 또 객체 있고 그러면
// 그냥
// 스트링지파이 쓰는게 낫다
// 즉, 
// 2단계일떄는 
// 마지막꺼 쓰라는 이야기다.
// 막,,무조건 제이슨 스트링지파이 이걸 쓰라는게 아니다. 최대한 안쓰는게 좋다 왜냐면 성능이 최악이다. 즉, 느려진다는거지...
// 그래서 
// 저 위에 두 애들을 왠만하면 쓰라는 이야기이다.

// 참고로
// JSON.parse(JSON.stringify(원하는 객체)) 
// 이거의 실행 순서는 JSON.stringify() 이거 1번
// 그다음 JSON.parse 가 마지막으로 실행됨
// 물런 처음 읽혀지는건 파스지만 그니까
// 함수처럼
// 앞에꺼 읽고 안에꺼 읽고 실행 종료 밖에꺼 종료
// 이런 식이니까 안에께 먼저 실행이 되는거고 종료한다음 밖에꼐 두번쨰로실행되고 종료되고
// 여튼 순서는 이렇다

// 즉, 함수의 특징인것이다.
// 함수 실행시
// 물런 실행이 먼저되고 안쪽으로 파고든다음 실행후 종료 종료 이런식이다.

// 즉, 스트링리가먼저 실행이 되고,
// 그다음 파스가 실행이 되는 순서인것이다.

// ----------------

// 참고로>>>>>

// Object.assign({},Object.create(프로토타입));이런게 있는데,,,

// 정리하자면

// slice(); 
// 슬라이스 이거는

// Object.keys(obj).forEach(function(key){
// 	obj2[key] = obj[key];

// 이거랑 같고
// 이거는
// 또 
// Object.assign(obj2,obj);  //1단계 복사시에는 이거 쓰는게 더 코드가 간단하고 쉽다.
// 이거랑 같은 방법이다.

// 이 셋의 공통점은 복사가 1단계만 된다는 단점이 있지만 이게 가장 많이 쓰인다.

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
